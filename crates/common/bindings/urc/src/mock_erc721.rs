/**

Generated by the following Solidity interface...
```solidity
interface MockERC721 {
	event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);
	event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);
	event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);

	function approve(address spender, uint256 id) external payable;
	function balanceOf(address owner) external view returns (uint256);
	function getApproved(uint256 id) external view returns (address);
	function initialize(string memory name_, string memory symbol_) external;
	function isApprovedForAll(address owner, address operator) external view returns (bool);
	function name() external view returns (string memory);
	function ownerOf(uint256 id) external view returns (address owner);
	function safeTransferFrom(address from, address to, uint256 id) external payable;
	function safeTransferFrom(address from, address to, uint256 id, bytes memory data) external payable;
	function setApprovalForAll(address operator, bool approved) external;
	function supportsInterface(bytes4 interfaceId) external view returns (bool);
	function symbol() external view returns (string memory);
	function tokenURI(uint256 id) external view returns (string memory);
	function transferFrom(address from, address to, uint256 id) external payable;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
	"type": "function",
	"name": "approve",
	"inputs": [
	  {
		"name": "spender",
		"type": "address",
		"internalType": "address"
	  },
	  {
		"name": "id",
		"type": "uint256",
		"internalType": "uint256"
	  }
	],
	"outputs": [],
	"stateMutability": "payable"
  },
  {
	"type": "function",
	"name": "balanceOf",
	"inputs": [
	  {
		"name": "owner",
		"type": "address",
		"internalType": "address"
	  }
	],
	"outputs": [
	  {
		"name": "",
		"type": "uint256",
		"internalType": "uint256"
	  }
	],
	"stateMutability": "view"
  },
  {
	"type": "function",
	"name": "getApproved",
	"inputs": [
	  {
		"name": "id",
		"type": "uint256",
		"internalType": "uint256"
	  }
	],
	"outputs": [
	  {
		"name": "",
		"type": "address",
		"internalType": "address"
	  }
	],
	"stateMutability": "view"
  },
  {
	"type": "function",
	"name": "initialize",
	"inputs": [
	  {
		"name": "name_",
		"type": "string",
		"internalType": "string"
	  },
	  {
		"name": "symbol_",
		"type": "string",
		"internalType": "string"
	  }
	],
	"outputs": [],
	"stateMutability": "nonpayable"
  },
  {
	"type": "function",
	"name": "isApprovedForAll",
	"inputs": [
	  {
		"name": "owner",
		"type": "address",
		"internalType": "address"
	  },
	  {
		"name": "operator",
		"type": "address",
		"internalType": "address"
	  }
	],
	"outputs": [
	  {
		"name": "",
		"type": "bool",
		"internalType": "bool"
	  }
	],
	"stateMutability": "view"
  },
  {
	"type": "function",
	"name": "name",
	"inputs": [],
	"outputs": [
	  {
		"name": "",
		"type": "string",
		"internalType": "string"
	  }
	],
	"stateMutability": "view"
  },
  {
	"type": "function",
	"name": "ownerOf",
	"inputs": [
	  {
		"name": "id",
		"type": "uint256",
		"internalType": "uint256"
	  }
	],
	"outputs": [
	  {
		"name": "owner",
		"type": "address",
		"internalType": "address"
	  }
	],
	"stateMutability": "view"
  },
  {
	"type": "function",
	"name": "safeTransferFrom",
	"inputs": [
	  {
		"name": "from",
		"type": "address",
		"internalType": "address"
	  },
	  {
		"name": "to",
		"type": "address",
		"internalType": "address"
	  },
	  {
		"name": "id",
		"type": "uint256",
		"internalType": "uint256"
	  }
	],
	"outputs": [],
	"stateMutability": "payable"
  },
  {
	"type": "function",
	"name": "safeTransferFrom",
	"inputs": [
	  {
		"name": "from",
		"type": "address",
		"internalType": "address"
	  },
	  {
		"name": "to",
		"type": "address",
		"internalType": "address"
	  },
	  {
		"name": "id",
		"type": "uint256",
		"internalType": "uint256"
	  },
	  {
		"name": "data",
		"type": "bytes",
		"internalType": "bytes"
	  }
	],
	"outputs": [],
	"stateMutability": "payable"
  },
  {
	"type": "function",
	"name": "setApprovalForAll",
	"inputs": [
	  {
		"name": "operator",
		"type": "address",
		"internalType": "address"
	  },
	  {
		"name": "approved",
		"type": "bool",
		"internalType": "bool"
	  }
	],
	"outputs": [],
	"stateMutability": "nonpayable"
  },
  {
	"type": "function",
	"name": "supportsInterface",
	"inputs": [
	  {
		"name": "interfaceId",
		"type": "bytes4",
		"internalType": "bytes4"
	  }
	],
	"outputs": [
	  {
		"name": "",
		"type": "bool",
		"internalType": "bool"
	  }
	],
	"stateMutability": "view"
  },
  {
	"type": "function",
	"name": "symbol",
	"inputs": [],
	"outputs": [
	  {
		"name": "",
		"type": "string",
		"internalType": "string"
	  }
	],
	"stateMutability": "view"
  },
  {
	"type": "function",
	"name": "tokenURI",
	"inputs": [
	  {
		"name": "id",
		"type": "uint256",
		"internalType": "uint256"
	  }
	],
	"outputs": [
	  {
		"name": "",
		"type": "string",
		"internalType": "string"
	  }
	],
	"stateMutability": "view"
  },
  {
	"type": "function",
	"name": "transferFrom",
	"inputs": [
	  {
		"name": "from",
		"type": "address",
		"internalType": "address"
	  },
	  {
		"name": "to",
		"type": "address",
		"internalType": "address"
	  },
	  {
		"name": "id",
		"type": "uint256",
		"internalType": "uint256"
	  }
	],
	"outputs": [],
	"stateMutability": "payable"
  },
  {
	"type": "event",
	"name": "Approval",
	"inputs": [
	  {
		"name": "_owner",
		"type": "address",
		"indexed": true,
		"internalType": "address"
	  },
	  {
		"name": "_approved",
		"type": "address",
		"indexed": true,
		"internalType": "address"
	  },
	  {
		"name": "_tokenId",
		"type": "uint256",
		"indexed": true,
		"internalType": "uint256"
	  }
	],
	"anonymous": false
  },
  {
	"type": "event",
	"name": "ApprovalForAll",
	"inputs": [
	  {
		"name": "_owner",
		"type": "address",
		"indexed": true,
		"internalType": "address"
	  },
	  {
		"name": "_operator",
		"type": "address",
		"indexed": true,
		"internalType": "address"
	  },
	  {
		"name": "_approved",
		"type": "bool",
		"indexed": false,
		"internalType": "bool"
	  }
	],
	"anonymous": false
  },
  {
	"type": "event",
	"name": "Transfer",
	"inputs": [
	  {
		"name": "_from",
		"type": "address",
		"indexed": true,
		"internalType": "address"
	  },
	  {
		"name": "_to",
		"type": "address",
		"indexed": true,
		"internalType": "address"
	  },
	  {
		"name": "_tokenId",
		"type": "uint256",
		"indexed": true,
		"internalType": "uint256"
	  }
	],
	"anonymous": false
  }
]
```*/
#[allow(
	non_camel_case_types,
	non_snake_case,
	clippy::pub_underscore_fields,
	clippy::style,
	clippy::empty_structs_with_brackets
)]
pub mod MockERC721 {
	use super::*;
	use alloy::sol_types as alloy_sol_types;
	/// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x6080604052348015600e575f80fd5b50610f088061001c5f395ff3fe6080604052600436106100d9575f3560e01c80636352211e1161007c578063a22cb46511610057578063a22cb46514610238578063b88d4fde14610257578063c87b56dd1461026a578063e985e9c51461028a575f80fd5b80636352211e146101d857806370a08231146101f757806395d89b4114610224575f80fd5b8063095ea7b3116100b7578063095ea7b31461017e57806323b872dd1461019357806342842e0e146101a65780634cd88b76146101b9575f80fd5b806301ffc9a7146100dd57806306fdde0314610111578063081812fc14610132575b5f80fd5b3480156100e8575f80fd5b506100fc6100f7366004610a08565b6102d1565b60405190151581526020015b60405180910390f35b34801561011c575f80fd5b50610125610322565b6040516101089190610a58565b34801561013d575f80fd5b5061016661014c366004610a6a565b5f908152600460205260409020546001600160a01b031690565b6040516001600160a01b039091168152602001610108565b61019161018c366004610a97565b6103b1565b005b6101916101a1366004610abf565b610495565b6101916101b4366004610abf565b610688565b3480156101c4575f80fd5b506101916101d3366004610b9d565b610773565b3480156101e3575f80fd5b506101666101f2366004610a6a565b6107e6565b348015610202575f80fd5b50610216610211366004610bfd565b61083c565b604051908152602001610108565b34801561022f575f80fd5b5061012561089d565b348015610243575f80fd5b50610191610252366004610c16565b6108ac565b610191610265366004610c4f565b610917565b348015610275575f80fd5b50610125610284366004610a6a565b50606090565b348015610295575f80fd5b506100fc6102a4366004610cc6565b6001600160a01b039182165f90815260056020908152604080832093909416825291909152205460ff1690565b5f6301ffc9a760e01b6001600160e01b03198316148061030157506380ac58cd60e01b6001600160e01b03198316145b8061031c5750635b5e139f60e01b6001600160e01b03198316145b92915050565b60605f805461033090610cf7565b80601f016020809104026020016040519081016040528092919081815260200182805461035c90610cf7565b80156103a75780601f1061037e576101008083540402835291602001916103a7565b820191905f5260205f20905b81548152906001019060200180831161038a57829003601f168201915b5050505050905090565b5f818152600260205260409020546001600160a01b0316338114806103f857506001600160a01b0381165f90815260056020908152604080832033845290915290205460ff165b61043a5760405162461bcd60e51b815260206004820152600e60248201526d1393d517d055551213d49256915160921b60448201526064015b60405180910390fd5b5f8281526004602052604080822080546001600160a01b0319166001600160a01b0387811691821790925591518593918516917f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92591a4505050565b5f818152600260205260409020546001600160a01b038481169116146104ea5760405162461bcd60e51b815260206004820152600a60248201526957524f4e475f46524f4d60b01b6044820152606401610431565b6001600160a01b0382166105345760405162461bcd60e51b81526020600482015260116024820152701253959053125117d49150d25412515395607a1b6044820152606401610431565b336001600160a01b038416148061056d57506001600160a01b0383165f90815260056020908152604080832033845290915290205460ff165b8061058d57505f818152600460205260409020546001600160a01b031633145b6105ca5760405162461bcd60e51b815260206004820152600e60248201526d1393d517d055551213d49256915160921b6044820152606401610431565b6001600160a01b0383165f9081526003602052604081208054916105ed83610d43565b90915550506001600160a01b0382165f90815260036020526040812080549161061583610d58565b90915550505f81815260026020908152604080832080546001600160a01b038088166001600160a01b031992831681179093556004909452828520805490911690559051849391928716917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef91a4505050565b610693838383610495565b813b158061072f5750604051630a85bd0160e11b8082523360048301526001600160a01b03858116602484015260448301849052608060648401525f608484015290919084169063150b7a029060a4016020604051808303815f875af11580156106ff573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906107239190610d70565b6001600160e01b031916145b61076e5760405162461bcd60e51b815260206004820152601060248201526f155394d0519157d49150d2541251539560821b6044820152606401610431565b505050565b60065460ff16156107bc5760405162461bcd60e51b81526020600482015260136024820152721053149150511657d253925512505312569151606a1b6044820152606401610431565b5f6107c78382610dd6565b5060016107d48282610dd6565b50506006805460ff1916600117905550565b5f818152600260205260409020546001600160a01b0316806108375760405162461bcd60e51b815260206004820152600a6024820152691393d517d3525395115160b21b6044820152606401610431565b919050565b5f6001600160a01b0382166108825760405162461bcd60e51b815260206004820152600c60248201526b5a45524f5f4144445245535360a01b6044820152606401610431565b506001600160a01b03165f9081526003602052604090205490565b60606001805461033090610cf7565b335f8181526005602090815260408083206001600160a01b03871680855290835292819020805460ff191686151590811790915590519081529192917f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a35050565b610922848484610495565b823b15806109ab5750604051630a85bd0160e11b808252906001600160a01b0385169063150b7a029061095f903390899088908890600401610e96565b6020604051808303815f875af115801561097b573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061099f9190610d70565b6001600160e01b031916145b6109ea5760405162461bcd60e51b815260206004820152601060248201526f155394d0519157d49150d2541251539560821b6044820152606401610431565b50505050565b6001600160e01b031981168114610a05575f80fd5b50565b5f60208284031215610a18575f80fd5b8135610a23816109f0565b9392505050565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b602081525f610a236020830184610a2a565b5f60208284031215610a7a575f80fd5b5035919050565b80356001600160a01b0381168114610837575f80fd5b5f8060408385031215610aa8575f80fd5b610ab183610a81565b946020939093013593505050565b5f805f60608486031215610ad1575f80fd5b610ada84610a81565b9250610ae860208501610a81565b9150604084013590509250925092565b634e487b7160e01b5f52604160045260245ffd5b5f67ffffffffffffffff80841115610b2657610b26610af8565b604051601f8501601f19908116603f01168101908282118183101715610b4e57610b4e610af8565b81604052809350858152868686011115610b66575f80fd5b858560208301375f602087830101525050509392505050565b5f82601f830112610b8e575f80fd5b610a2383833560208501610b0c565b5f8060408385031215610bae575f80fd5b823567ffffffffffffffff80821115610bc5575f80fd5b610bd186838701610b7f565b93506020850135915080821115610be6575f80fd5b50610bf385828601610b7f565b9150509250929050565b5f60208284031215610c0d575f80fd5b610a2382610a81565b5f8060408385031215610c27575f80fd5b610c3083610a81565b915060208301358015158114610c44575f80fd5b809150509250929050565b5f805f8060808587031215610c62575f80fd5b610c6b85610a81565b9350610c7960208601610a81565b925060408501359150606085013567ffffffffffffffff811115610c9b575f80fd5b8501601f81018713610cab575f80fd5b610cba87823560208401610b0c565b91505092959194509250565b5f8060408385031215610cd7575f80fd5b610ce083610a81565b9150610cee60208401610a81565b90509250929050565b600181811c90821680610d0b57607f821691505b602082108103610d2957634e487b7160e01b5f52602260045260245ffd5b50919050565b634e487b7160e01b5f52601160045260245ffd5b5f81610d5157610d51610d2f565b505f190190565b5f60018201610d6957610d69610d2f565b5060010190565b5f60208284031215610d80575f80fd5b8151610a23816109f0565b601f82111561076e57805f5260205f20601f840160051c81016020851015610db05750805b601f840160051c820191505b81811015610dcf575f8155600101610dbc565b5050505050565b815167ffffffffffffffff811115610df057610df0610af8565b610e0481610dfe8454610cf7565b84610d8b565b602080601f831160018114610e37575f8415610e205750858301515b5f19600386901b1c1916600185901b178555610e8e565b5f85815260208120601f198616915b82811015610e6557888601518255948401946001909101908401610e46565b5085821015610e8257878501515f19600388901b60f8161c191681555b505060018460011b0185555b505050505050565b6001600160a01b03858116825284166020820152604081018390526080606082018190525f90610ec890830184610a2a565b969550505050505056fea2646970667358221220eaccc25aadf8bc5af3f835c0ac3a34704f36e02bcc238ab3f7d3c745e12afa5564736f6c63430008190033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15`\x0EW_\x80\xFD[Pa\x0F\x08\x80a\0\x1C_9_\xF3\xFE`\x80`@R`\x046\x10a\0\xD9W_5`\xE0\x1C\x80ccR!\x1E\x11a\0|W\x80c\xA2,\xB4e\x11a\0WW\x80c\xA2,\xB4e\x14a\x028W\x80c\xB8\x8DO\xDE\x14a\x02WW\x80c\xC8{V\xDD\x14a\x02jW\x80c\xE9\x85\xE9\xC5\x14a\x02\x8AW_\x80\xFD[\x80ccR!\x1E\x14a\x01\xD8W\x80cp\xA0\x821\x14a\x01\xF7W\x80c\x95\xD8\x9BA\x14a\x02$W_\x80\xFD[\x80c\t^\xA7\xB3\x11a\0\xB7W\x80c\t^\xA7\xB3\x14a\x01~W\x80c#\xB8r\xDD\x14a\x01\x93W\x80cB\x84.\x0E\x14a\x01\xA6W\x80cL\xD8\x8Bv\x14a\x01\xB9W_\x80\xFD[\x80c\x01\xFF\xC9\xA7\x14a\0\xDDW\x80c\x06\xFD\xDE\x03\x14a\x01\x11W\x80c\x08\x18\x12\xFC\x14a\x012W[_\x80\xFD[4\x80\x15a\0\xE8W_\x80\xFD[Pa\0\xFCa\0\xF76`\x04a\n\x08V[a\x02\xD1V[`@Q\x90\x15\x15\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x01\x1CW_\x80\xFD[Pa\x01%a\x03\"V[`@Qa\x01\x08\x91\x90a\nXV[4\x80\x15a\x01=W_\x80\xFD[Pa\x01fa\x01L6`\x04a\njV[_\x90\x81R`\x04` R`@\x90 T`\x01`\x01`\xA0\x1B\x03\x16\x90V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\x01\x08V[a\x01\x91a\x01\x8C6`\x04a\n\x97V[a\x03\xB1V[\0[a\x01\x91a\x01\xA16`\x04a\n\xBFV[a\x04\x95V[a\x01\x91a\x01\xB46`\x04a\n\xBFV[a\x06\x88V[4\x80\x15a\x01\xC4W_\x80\xFD[Pa\x01\x91a\x01\xD36`\x04a\x0B\x9DV[a\x07sV[4\x80\x15a\x01\xE3W_\x80\xFD[Pa\x01fa\x01\xF26`\x04a\njV[a\x07\xE6V[4\x80\x15a\x02\x02W_\x80\xFD[Pa\x02\x16a\x02\x116`\x04a\x0B\xFDV[a\x08<V[`@Q\x90\x81R` \x01a\x01\x08V[4\x80\x15a\x02/W_\x80\xFD[Pa\x01%a\x08\x9DV[4\x80\x15a\x02CW_\x80\xFD[Pa\x01\x91a\x02R6`\x04a\x0C\x16V[a\x08\xACV[a\x01\x91a\x02e6`\x04a\x0COV[a\t\x17V[4\x80\x15a\x02uW_\x80\xFD[Pa\x01%a\x02\x846`\x04a\njV[P``\x90V[4\x80\x15a\x02\x95W_\x80\xFD[Pa\0\xFCa\x02\xA46`\x04a\x0C\xC6V[`\x01`\x01`\xA0\x1B\x03\x91\x82\x16_\x90\x81R`\x05` \x90\x81R`@\x80\x83 \x93\x90\x94\x16\x82R\x91\x90\x91R T`\xFF\x16\x90V[_c\x01\xFF\xC9\xA7`\xE0\x1B`\x01`\x01`\xE0\x1B\x03\x19\x83\x16\x14\x80a\x03\x01WPc\x80\xACX\xCD`\xE0\x1B`\x01`\x01`\xE0\x1B\x03\x19\x83\x16\x14[\x80a\x03\x1CWPc[^\x13\x9F`\xE0\x1B`\x01`\x01`\xE0\x1B\x03\x19\x83\x16\x14[\x92\x91PPV[``_\x80Ta\x030\x90a\x0C\xF7V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x03\\\x90a\x0C\xF7V[\x80\x15a\x03\xA7W\x80`\x1F\x10a\x03~Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x03\xA7V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x03\x8AW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x90P\x90V[_\x81\x81R`\x02` R`@\x90 T`\x01`\x01`\xA0\x1B\x03\x163\x81\x14\x80a\x03\xF8WP`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R`\x05` \x90\x81R`@\x80\x83 3\x84R\x90\x91R\x90 T`\xFF\x16[a\x04:W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0E`$\x82\x01Rm\x13\x93\xD5\x17\xD0UU\x12\x13\xD4\x92V\x91Q`\x92\x1B`D\x82\x01R`d\x01[`@Q\x80\x91\x03\x90\xFD[_\x82\x81R`\x04` R`@\x80\x82 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x87\x81\x16\x91\x82\x17\x90\x92U\x91Q\x85\x93\x91\x85\x16\x91\x7F\x8C[\xE1\xE5\xEB\xEC}[\xD1OqB}\x1E\x84\xF3\xDD\x03\x14\xC0\xF7\xB2)\x1E[ \n\xC8\xC7\xC3\xB9%\x91\xA4PPPV[_\x81\x81R`\x02` R`@\x90 T`\x01`\x01`\xA0\x1B\x03\x84\x81\x16\x91\x16\x14a\x04\xEAW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\n`$\x82\x01RiWRONG_FROM`\xB0\x1B`D\x82\x01R`d\x01a\x041V[`\x01`\x01`\xA0\x1B\x03\x82\x16a\x054W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x11`$\x82\x01Rp\x12S\x95\x90S\x12Q\x17\xD4\x91P\xD2T\x12QS\x95`z\x1B`D\x82\x01R`d\x01a\x041V[3`\x01`\x01`\xA0\x1B\x03\x84\x16\x14\x80a\x05mWP`\x01`\x01`\xA0\x1B\x03\x83\x16_\x90\x81R`\x05` \x90\x81R`@\x80\x83 3\x84R\x90\x91R\x90 T`\xFF\x16[\x80a\x05\x8DWP_\x81\x81R`\x04` R`@\x90 T`\x01`\x01`\xA0\x1B\x03\x163\x14[a\x05\xCAW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0E`$\x82\x01Rm\x13\x93\xD5\x17\xD0UU\x12\x13\xD4\x92V\x91Q`\x92\x1B`D\x82\x01R`d\x01a\x041V[`\x01`\x01`\xA0\x1B\x03\x83\x16_\x90\x81R`\x03` R`@\x81 \x80T\x91a\x05\xED\x83a\rCV[\x90\x91UPP`\x01`\x01`\xA0\x1B\x03\x82\x16_\x90\x81R`\x03` R`@\x81 \x80T\x91a\x06\x15\x83a\rXV[\x90\x91UPP_\x81\x81R`\x02` \x90\x81R`@\x80\x83 \x80T`\x01`\x01`\xA0\x1B\x03\x80\x88\x16`\x01`\x01`\xA0\x1B\x03\x19\x92\x83\x16\x81\x17\x90\x93U`\x04\x90\x94R\x82\x85 \x80T\x90\x91\x16\x90U\x90Q\x84\x93\x91\x92\x87\x16\x91\x7F\xDD\xF2R\xAD\x1B\xE2\xC8\x9Bi\xC2\xB0h\xFC7\x8D\xAA\x95+\xA7\xF1c\xC4\xA1\x16(\xF5ZM\xF5#\xB3\xEF\x91\xA4PPPV[a\x06\x93\x83\x83\x83a\x04\x95V[\x81;\x15\x80a\x07/WP`@Qc\n\x85\xBD\x01`\xE1\x1B\x80\x82R3`\x04\x83\x01R`\x01`\x01`\xA0\x1B\x03\x85\x81\x16`$\x84\x01R`D\x83\x01\x84\x90R`\x80`d\x84\x01R_`\x84\x84\x01R\x90\x91\x90\x84\x16\x90c\x15\x0Bz\x02\x90`\xA4\x01` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\x06\xFFW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x07#\x91\x90a\rpV[`\x01`\x01`\xE0\x1B\x03\x19\x16\x14[a\x07nW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x10`$\x82\x01Ro\x15S\x94\xD0Q\x91W\xD4\x91P\xD2T\x12QS\x95`\x82\x1B`D\x82\x01R`d\x01a\x041V[PPPV[`\x06T`\xFF\x16\x15a\x07\xBCW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x13`$\x82\x01Rr\x10S\x14\x91PQ\x16W\xD2S\x92U\x12PS\x12V\x91Q`j\x1B`D\x82\x01R`d\x01a\x041V[_a\x07\xC7\x83\x82a\r\xD6V[P`\x01a\x07\xD4\x82\x82a\r\xD6V[PP`\x06\x80T`\xFF\x19\x16`\x01\x17\x90UPV[_\x81\x81R`\x02` R`@\x90 T`\x01`\x01`\xA0\x1B\x03\x16\x80a\x087W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\n`$\x82\x01Ri\x13\x93\xD5\x17\xD3RS\x95\x11Q`\xB2\x1B`D\x82\x01R`d\x01a\x041V[\x91\x90PV[_`\x01`\x01`\xA0\x1B\x03\x82\x16a\x08\x82W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0C`$\x82\x01RkZERO_ADDRESS`\xA0\x1B`D\x82\x01R`d\x01a\x041V[P`\x01`\x01`\xA0\x1B\x03\x16_\x90\x81R`\x03` R`@\x90 T\x90V[```\x01\x80Ta\x030\x90a\x0C\xF7V[3_\x81\x81R`\x05` \x90\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x87\x16\x80\x85R\x90\x83R\x92\x81\x90 \x80T`\xFF\x19\x16\x86\x15\x15\x90\x81\x17\x90\x91U\x90Q\x90\x81R\x91\x92\x91\x7F\x170~\xAB9\xABa\x07\xE8\x89\x98E\xAD=Y\xBD\x96S\xF2\0\xF2 \x92\x04\x89\xCA+Y7il1\x91\x01`@Q\x80\x91\x03\x90\xA3PPV[a\t\"\x84\x84\x84a\x04\x95V[\x82;\x15\x80a\t\xABWP`@Qc\n\x85\xBD\x01`\xE1\x1B\x80\x82R\x90`\x01`\x01`\xA0\x1B\x03\x85\x16\x90c\x15\x0Bz\x02\x90a\t_\x903\x90\x89\x90\x88\x90\x88\x90`\x04\x01a\x0E\x96V[` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\t{W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\t\x9F\x91\x90a\rpV[`\x01`\x01`\xE0\x1B\x03\x19\x16\x14[a\t\xEAW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x10`$\x82\x01Ro\x15S\x94\xD0Q\x91W\xD4\x91P\xD2T\x12QS\x95`\x82\x1B`D\x82\x01R`d\x01a\x041V[PPPPV[`\x01`\x01`\xE0\x1B\x03\x19\x81\x16\x81\x14a\n\x05W_\x80\xFD[PV[_` \x82\x84\x03\x12\x15a\n\x18W_\x80\xFD[\x815a\n#\x81a\t\xF0V[\x93\x92PPPV[_\x81Q\x80\x84R\x80` \x84\x01` \x86\x01^_` \x82\x86\x01\x01R` `\x1F\x19`\x1F\x83\x01\x16\x85\x01\x01\x91PP\x92\x91PPV[` \x81R_a\n#` \x83\x01\x84a\n*V[_` \x82\x84\x03\x12\x15a\nzW_\x80\xFD[P5\x91\x90PV[\x805`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x087W_\x80\xFD[_\x80`@\x83\x85\x03\x12\x15a\n\xA8W_\x80\xFD[a\n\xB1\x83a\n\x81V[\x94` \x93\x90\x93\x015\x93PPPV[_\x80_``\x84\x86\x03\x12\x15a\n\xD1W_\x80\xFD[a\n\xDA\x84a\n\x81V[\x92Pa\n\xE8` \x85\x01a\n\x81V[\x91P`@\x84\x015\x90P\x92P\x92P\x92V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x84\x11\x15a\x0B&Wa\x0B&a\n\xF8V[`@Q`\x1F\x85\x01`\x1F\x19\x90\x81\x16`?\x01\x16\x81\x01\x90\x82\x82\x11\x81\x83\x10\x17\x15a\x0BNWa\x0BNa\n\xF8V[\x81`@R\x80\x93P\x85\x81R\x86\x86\x86\x01\x11\x15a\x0BfW_\x80\xFD[\x85\x85` \x83\x017_` \x87\x83\x01\x01RPPP\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a\x0B\x8EW_\x80\xFD[a\n#\x83\x835` \x85\x01a\x0B\x0CV[_\x80`@\x83\x85\x03\x12\x15a\x0B\xAEW_\x80\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15a\x0B\xC5W_\x80\xFD[a\x0B\xD1\x86\x83\x87\x01a\x0B\x7FV[\x93P` \x85\x015\x91P\x80\x82\x11\x15a\x0B\xE6W_\x80\xFD[Pa\x0B\xF3\x85\x82\x86\x01a\x0B\x7FV[\x91PP\x92P\x92\x90PV[_` \x82\x84\x03\x12\x15a\x0C\rW_\x80\xFD[a\n#\x82a\n\x81V[_\x80`@\x83\x85\x03\x12\x15a\x0C'W_\x80\xFD[a\x0C0\x83a\n\x81V[\x91P` \x83\x015\x80\x15\x15\x81\x14a\x0CDW_\x80\xFD[\x80\x91PP\x92P\x92\x90PV[_\x80_\x80`\x80\x85\x87\x03\x12\x15a\x0CbW_\x80\xFD[a\x0Ck\x85a\n\x81V[\x93Pa\x0Cy` \x86\x01a\n\x81V[\x92P`@\x85\x015\x91P``\x85\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x0C\x9BW_\x80\xFD[\x85\x01`\x1F\x81\x01\x87\x13a\x0C\xABW_\x80\xFD[a\x0C\xBA\x87\x825` \x84\x01a\x0B\x0CV[\x91PP\x92\x95\x91\x94P\x92PV[_\x80`@\x83\x85\x03\x12\x15a\x0C\xD7W_\x80\xFD[a\x0C\xE0\x83a\n\x81V[\x91Pa\x0C\xEE` \x84\x01a\n\x81V[\x90P\x92P\x92\x90PV[`\x01\x81\x81\x1C\x90\x82\x16\x80a\r\x0BW`\x7F\x82\x16\x91P[` \x82\x10\x81\x03a\r)WcNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[P\x91\x90PV[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[_\x81a\rQWa\rQa\r/V[P_\x19\x01\x90V[_`\x01\x82\x01a\riWa\ria\r/V[P`\x01\x01\x90V[_` \x82\x84\x03\x12\x15a\r\x80W_\x80\xFD[\x81Qa\n#\x81a\t\xF0V[`\x1F\x82\x11\x15a\x07nW\x80_R` _ `\x1F\x84\x01`\x05\x1C\x81\x01` \x85\x10\x15a\r\xB0WP\x80[`\x1F\x84\x01`\x05\x1C\x82\x01\x91P[\x81\x81\x10\x15a\r\xCFW_\x81U`\x01\x01a\r\xBCV[PPPPPV[\x81Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\r\xF0Wa\r\xF0a\n\xF8V[a\x0E\x04\x81a\r\xFE\x84Ta\x0C\xF7V[\x84a\r\x8BV[` \x80`\x1F\x83\x11`\x01\x81\x14a\x0E7W_\x84\x15a\x0E WP\x85\x83\x01Q[_\x19`\x03\x86\x90\x1B\x1C\x19\x16`\x01\x85\x90\x1B\x17\x85Ua\x0E\x8EV[_\x85\x81R` \x81 `\x1F\x19\x86\x16\x91[\x82\x81\x10\x15a\x0EeW\x88\x86\x01Q\x82U\x94\x84\x01\x94`\x01\x90\x91\x01\x90\x84\x01a\x0EFV[P\x85\x82\x10\x15a\x0E\x82W\x87\x85\x01Q_\x19`\x03\x88\x90\x1B`\xF8\x16\x1C\x19\x16\x81U[PP`\x01\x84`\x01\x1B\x01\x85U[PPPPPPV[`\x01`\x01`\xA0\x1B\x03\x85\x81\x16\x82R\x84\x16` \x82\x01R`@\x81\x01\x83\x90R`\x80``\x82\x01\x81\x90R_\x90a\x0E\xC8\x90\x83\x01\x84a\n*V[\x96\x95PPPPPPV\xFE\xA2dipfsX\"\x12 \xEA\xCC\xC2Z\xAD\xF8\xBCZ\xF3\xF85\xC0\xAC:4pO6\xE0+\xCC#\x8A\xB3\xF7\xD3\xC7E\xE1*\xFAUdsolcC\0\x08\x19\x003",
    );
	/// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x6080604052600436106100d9575f3560e01c80636352211e1161007c578063a22cb46511610057578063a22cb46514610238578063b88d4fde14610257578063c87b56dd1461026a578063e985e9c51461028a575f80fd5b80636352211e146101d857806370a08231146101f757806395d89b4114610224575f80fd5b8063095ea7b3116100b7578063095ea7b31461017e57806323b872dd1461019357806342842e0e146101a65780634cd88b76146101b9575f80fd5b806301ffc9a7146100dd57806306fdde0314610111578063081812fc14610132575b5f80fd5b3480156100e8575f80fd5b506100fc6100f7366004610a08565b6102d1565b60405190151581526020015b60405180910390f35b34801561011c575f80fd5b50610125610322565b6040516101089190610a58565b34801561013d575f80fd5b5061016661014c366004610a6a565b5f908152600460205260409020546001600160a01b031690565b6040516001600160a01b039091168152602001610108565b61019161018c366004610a97565b6103b1565b005b6101916101a1366004610abf565b610495565b6101916101b4366004610abf565b610688565b3480156101c4575f80fd5b506101916101d3366004610b9d565b610773565b3480156101e3575f80fd5b506101666101f2366004610a6a565b6107e6565b348015610202575f80fd5b50610216610211366004610bfd565b61083c565b604051908152602001610108565b34801561022f575f80fd5b5061012561089d565b348015610243575f80fd5b50610191610252366004610c16565b6108ac565b610191610265366004610c4f565b610917565b348015610275575f80fd5b50610125610284366004610a6a565b50606090565b348015610295575f80fd5b506100fc6102a4366004610cc6565b6001600160a01b039182165f90815260056020908152604080832093909416825291909152205460ff1690565b5f6301ffc9a760e01b6001600160e01b03198316148061030157506380ac58cd60e01b6001600160e01b03198316145b8061031c5750635b5e139f60e01b6001600160e01b03198316145b92915050565b60605f805461033090610cf7565b80601f016020809104026020016040519081016040528092919081815260200182805461035c90610cf7565b80156103a75780601f1061037e576101008083540402835291602001916103a7565b820191905f5260205f20905b81548152906001019060200180831161038a57829003601f168201915b5050505050905090565b5f818152600260205260409020546001600160a01b0316338114806103f857506001600160a01b0381165f90815260056020908152604080832033845290915290205460ff165b61043a5760405162461bcd60e51b815260206004820152600e60248201526d1393d517d055551213d49256915160921b60448201526064015b60405180910390fd5b5f8281526004602052604080822080546001600160a01b0319166001600160a01b0387811691821790925591518593918516917f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92591a4505050565b5f818152600260205260409020546001600160a01b038481169116146104ea5760405162461bcd60e51b815260206004820152600a60248201526957524f4e475f46524f4d60b01b6044820152606401610431565b6001600160a01b0382166105345760405162461bcd60e51b81526020600482015260116024820152701253959053125117d49150d25412515395607a1b6044820152606401610431565b336001600160a01b038416148061056d57506001600160a01b0383165f90815260056020908152604080832033845290915290205460ff165b8061058d57505f818152600460205260409020546001600160a01b031633145b6105ca5760405162461bcd60e51b815260206004820152600e60248201526d1393d517d055551213d49256915160921b6044820152606401610431565b6001600160a01b0383165f9081526003602052604081208054916105ed83610d43565b90915550506001600160a01b0382165f90815260036020526040812080549161061583610d58565b90915550505f81815260026020908152604080832080546001600160a01b038088166001600160a01b031992831681179093556004909452828520805490911690559051849391928716917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef91a4505050565b610693838383610495565b813b158061072f5750604051630a85bd0160e11b8082523360048301526001600160a01b03858116602484015260448301849052608060648401525f608484015290919084169063150b7a029060a4016020604051808303815f875af11580156106ff573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906107239190610d70565b6001600160e01b031916145b61076e5760405162461bcd60e51b815260206004820152601060248201526f155394d0519157d49150d2541251539560821b6044820152606401610431565b505050565b60065460ff16156107bc5760405162461bcd60e51b81526020600482015260136024820152721053149150511657d253925512505312569151606a1b6044820152606401610431565b5f6107c78382610dd6565b5060016107d48282610dd6565b50506006805460ff1916600117905550565b5f818152600260205260409020546001600160a01b0316806108375760405162461bcd60e51b815260206004820152600a6024820152691393d517d3525395115160b21b6044820152606401610431565b919050565b5f6001600160a01b0382166108825760405162461bcd60e51b815260206004820152600c60248201526b5a45524f5f4144445245535360a01b6044820152606401610431565b506001600160a01b03165f9081526003602052604090205490565b60606001805461033090610cf7565b335f8181526005602090815260408083206001600160a01b03871680855290835292819020805460ff191686151590811790915590519081529192917f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a35050565b610922848484610495565b823b15806109ab5750604051630a85bd0160e11b808252906001600160a01b0385169063150b7a029061095f903390899088908890600401610e96565b6020604051808303815f875af115801561097b573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061099f9190610d70565b6001600160e01b031916145b6109ea5760405162461bcd60e51b815260206004820152601060248201526f155394d0519157d49150d2541251539560821b6044820152606401610431565b50505050565b6001600160e01b031981168114610a05575f80fd5b50565b5f60208284031215610a18575f80fd5b8135610a23816109f0565b9392505050565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b602081525f610a236020830184610a2a565b5f60208284031215610a7a575f80fd5b5035919050565b80356001600160a01b0381168114610837575f80fd5b5f8060408385031215610aa8575f80fd5b610ab183610a81565b946020939093013593505050565b5f805f60608486031215610ad1575f80fd5b610ada84610a81565b9250610ae860208501610a81565b9150604084013590509250925092565b634e487b7160e01b5f52604160045260245ffd5b5f67ffffffffffffffff80841115610b2657610b26610af8565b604051601f8501601f19908116603f01168101908282118183101715610b4e57610b4e610af8565b81604052809350858152868686011115610b66575f80fd5b858560208301375f602087830101525050509392505050565b5f82601f830112610b8e575f80fd5b610a2383833560208501610b0c565b5f8060408385031215610bae575f80fd5b823567ffffffffffffffff80821115610bc5575f80fd5b610bd186838701610b7f565b93506020850135915080821115610be6575f80fd5b50610bf385828601610b7f565b9150509250929050565b5f60208284031215610c0d575f80fd5b610a2382610a81565b5f8060408385031215610c27575f80fd5b610c3083610a81565b915060208301358015158114610c44575f80fd5b809150509250929050565b5f805f8060808587031215610c62575f80fd5b610c6b85610a81565b9350610c7960208601610a81565b925060408501359150606085013567ffffffffffffffff811115610c9b575f80fd5b8501601f81018713610cab575f80fd5b610cba87823560208401610b0c565b91505092959194509250565b5f8060408385031215610cd7575f80fd5b610ce083610a81565b9150610cee60208401610a81565b90509250929050565b600181811c90821680610d0b57607f821691505b602082108103610d2957634e487b7160e01b5f52602260045260245ffd5b50919050565b634e487b7160e01b5f52601160045260245ffd5b5f81610d5157610d51610d2f565b505f190190565b5f60018201610d6957610d69610d2f565b5060010190565b5f60208284031215610d80575f80fd5b8151610a23816109f0565b601f82111561076e57805f5260205f20601f840160051c81016020851015610db05750805b601f840160051c820191505b81811015610dcf575f8155600101610dbc565b5050505050565b815167ffffffffffffffff811115610df057610df0610af8565b610e0481610dfe8454610cf7565b84610d8b565b602080601f831160018114610e37575f8415610e205750858301515b5f19600386901b1c1916600185901b178555610e8e565b5f85815260208120601f198616915b82811015610e6557888601518255948401946001909101908401610e46565b5085821015610e8257878501515f19600388901b60f8161c191681555b505060018460011b0185555b505050505050565b6001600160a01b03858116825284166020820152604081018390526080606082018190525f90610ec890830184610a2a565b969550505050505056fea2646970667358221220eaccc25aadf8bc5af3f835c0ac3a34704f36e02bcc238ab3f7d3c745e12afa5564736f6c63430008190033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10a\0\xD9W_5`\xE0\x1C\x80ccR!\x1E\x11a\0|W\x80c\xA2,\xB4e\x11a\0WW\x80c\xA2,\xB4e\x14a\x028W\x80c\xB8\x8DO\xDE\x14a\x02WW\x80c\xC8{V\xDD\x14a\x02jW\x80c\xE9\x85\xE9\xC5\x14a\x02\x8AW_\x80\xFD[\x80ccR!\x1E\x14a\x01\xD8W\x80cp\xA0\x821\x14a\x01\xF7W\x80c\x95\xD8\x9BA\x14a\x02$W_\x80\xFD[\x80c\t^\xA7\xB3\x11a\0\xB7W\x80c\t^\xA7\xB3\x14a\x01~W\x80c#\xB8r\xDD\x14a\x01\x93W\x80cB\x84.\x0E\x14a\x01\xA6W\x80cL\xD8\x8Bv\x14a\x01\xB9W_\x80\xFD[\x80c\x01\xFF\xC9\xA7\x14a\0\xDDW\x80c\x06\xFD\xDE\x03\x14a\x01\x11W\x80c\x08\x18\x12\xFC\x14a\x012W[_\x80\xFD[4\x80\x15a\0\xE8W_\x80\xFD[Pa\0\xFCa\0\xF76`\x04a\n\x08V[a\x02\xD1V[`@Q\x90\x15\x15\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x01\x1CW_\x80\xFD[Pa\x01%a\x03\"V[`@Qa\x01\x08\x91\x90a\nXV[4\x80\x15a\x01=W_\x80\xFD[Pa\x01fa\x01L6`\x04a\njV[_\x90\x81R`\x04` R`@\x90 T`\x01`\x01`\xA0\x1B\x03\x16\x90V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\x01\x08V[a\x01\x91a\x01\x8C6`\x04a\n\x97V[a\x03\xB1V[\0[a\x01\x91a\x01\xA16`\x04a\n\xBFV[a\x04\x95V[a\x01\x91a\x01\xB46`\x04a\n\xBFV[a\x06\x88V[4\x80\x15a\x01\xC4W_\x80\xFD[Pa\x01\x91a\x01\xD36`\x04a\x0B\x9DV[a\x07sV[4\x80\x15a\x01\xE3W_\x80\xFD[Pa\x01fa\x01\xF26`\x04a\njV[a\x07\xE6V[4\x80\x15a\x02\x02W_\x80\xFD[Pa\x02\x16a\x02\x116`\x04a\x0B\xFDV[a\x08<V[`@Q\x90\x81R` \x01a\x01\x08V[4\x80\x15a\x02/W_\x80\xFD[Pa\x01%a\x08\x9DV[4\x80\x15a\x02CW_\x80\xFD[Pa\x01\x91a\x02R6`\x04a\x0C\x16V[a\x08\xACV[a\x01\x91a\x02e6`\x04a\x0COV[a\t\x17V[4\x80\x15a\x02uW_\x80\xFD[Pa\x01%a\x02\x846`\x04a\njV[P``\x90V[4\x80\x15a\x02\x95W_\x80\xFD[Pa\0\xFCa\x02\xA46`\x04a\x0C\xC6V[`\x01`\x01`\xA0\x1B\x03\x91\x82\x16_\x90\x81R`\x05` \x90\x81R`@\x80\x83 \x93\x90\x94\x16\x82R\x91\x90\x91R T`\xFF\x16\x90V[_c\x01\xFF\xC9\xA7`\xE0\x1B`\x01`\x01`\xE0\x1B\x03\x19\x83\x16\x14\x80a\x03\x01WPc\x80\xACX\xCD`\xE0\x1B`\x01`\x01`\xE0\x1B\x03\x19\x83\x16\x14[\x80a\x03\x1CWPc[^\x13\x9F`\xE0\x1B`\x01`\x01`\xE0\x1B\x03\x19\x83\x16\x14[\x92\x91PPV[``_\x80Ta\x030\x90a\x0C\xF7V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x03\\\x90a\x0C\xF7V[\x80\x15a\x03\xA7W\x80`\x1F\x10a\x03~Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x03\xA7V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x03\x8AW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x90P\x90V[_\x81\x81R`\x02` R`@\x90 T`\x01`\x01`\xA0\x1B\x03\x163\x81\x14\x80a\x03\xF8WP`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R`\x05` \x90\x81R`@\x80\x83 3\x84R\x90\x91R\x90 T`\xFF\x16[a\x04:W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0E`$\x82\x01Rm\x13\x93\xD5\x17\xD0UU\x12\x13\xD4\x92V\x91Q`\x92\x1B`D\x82\x01R`d\x01[`@Q\x80\x91\x03\x90\xFD[_\x82\x81R`\x04` R`@\x80\x82 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x87\x81\x16\x91\x82\x17\x90\x92U\x91Q\x85\x93\x91\x85\x16\x91\x7F\x8C[\xE1\xE5\xEB\xEC}[\xD1OqB}\x1E\x84\xF3\xDD\x03\x14\xC0\xF7\xB2)\x1E[ \n\xC8\xC7\xC3\xB9%\x91\xA4PPPV[_\x81\x81R`\x02` R`@\x90 T`\x01`\x01`\xA0\x1B\x03\x84\x81\x16\x91\x16\x14a\x04\xEAW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\n`$\x82\x01RiWRONG_FROM`\xB0\x1B`D\x82\x01R`d\x01a\x041V[`\x01`\x01`\xA0\x1B\x03\x82\x16a\x054W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x11`$\x82\x01Rp\x12S\x95\x90S\x12Q\x17\xD4\x91P\xD2T\x12QS\x95`z\x1B`D\x82\x01R`d\x01a\x041V[3`\x01`\x01`\xA0\x1B\x03\x84\x16\x14\x80a\x05mWP`\x01`\x01`\xA0\x1B\x03\x83\x16_\x90\x81R`\x05` \x90\x81R`@\x80\x83 3\x84R\x90\x91R\x90 T`\xFF\x16[\x80a\x05\x8DWP_\x81\x81R`\x04` R`@\x90 T`\x01`\x01`\xA0\x1B\x03\x163\x14[a\x05\xCAW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0E`$\x82\x01Rm\x13\x93\xD5\x17\xD0UU\x12\x13\xD4\x92V\x91Q`\x92\x1B`D\x82\x01R`d\x01a\x041V[`\x01`\x01`\xA0\x1B\x03\x83\x16_\x90\x81R`\x03` R`@\x81 \x80T\x91a\x05\xED\x83a\rCV[\x90\x91UPP`\x01`\x01`\xA0\x1B\x03\x82\x16_\x90\x81R`\x03` R`@\x81 \x80T\x91a\x06\x15\x83a\rXV[\x90\x91UPP_\x81\x81R`\x02` \x90\x81R`@\x80\x83 \x80T`\x01`\x01`\xA0\x1B\x03\x80\x88\x16`\x01`\x01`\xA0\x1B\x03\x19\x92\x83\x16\x81\x17\x90\x93U`\x04\x90\x94R\x82\x85 \x80T\x90\x91\x16\x90U\x90Q\x84\x93\x91\x92\x87\x16\x91\x7F\xDD\xF2R\xAD\x1B\xE2\xC8\x9Bi\xC2\xB0h\xFC7\x8D\xAA\x95+\xA7\xF1c\xC4\xA1\x16(\xF5ZM\xF5#\xB3\xEF\x91\xA4PPPV[a\x06\x93\x83\x83\x83a\x04\x95V[\x81;\x15\x80a\x07/WP`@Qc\n\x85\xBD\x01`\xE1\x1B\x80\x82R3`\x04\x83\x01R`\x01`\x01`\xA0\x1B\x03\x85\x81\x16`$\x84\x01R`D\x83\x01\x84\x90R`\x80`d\x84\x01R_`\x84\x84\x01R\x90\x91\x90\x84\x16\x90c\x15\x0Bz\x02\x90`\xA4\x01` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\x06\xFFW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x07#\x91\x90a\rpV[`\x01`\x01`\xE0\x1B\x03\x19\x16\x14[a\x07nW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x10`$\x82\x01Ro\x15S\x94\xD0Q\x91W\xD4\x91P\xD2T\x12QS\x95`\x82\x1B`D\x82\x01R`d\x01a\x041V[PPPV[`\x06T`\xFF\x16\x15a\x07\xBCW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x13`$\x82\x01Rr\x10S\x14\x91PQ\x16W\xD2S\x92U\x12PS\x12V\x91Q`j\x1B`D\x82\x01R`d\x01a\x041V[_a\x07\xC7\x83\x82a\r\xD6V[P`\x01a\x07\xD4\x82\x82a\r\xD6V[PP`\x06\x80T`\xFF\x19\x16`\x01\x17\x90UPV[_\x81\x81R`\x02` R`@\x90 T`\x01`\x01`\xA0\x1B\x03\x16\x80a\x087W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\n`$\x82\x01Ri\x13\x93\xD5\x17\xD3RS\x95\x11Q`\xB2\x1B`D\x82\x01R`d\x01a\x041V[\x91\x90PV[_`\x01`\x01`\xA0\x1B\x03\x82\x16a\x08\x82W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0C`$\x82\x01RkZERO_ADDRESS`\xA0\x1B`D\x82\x01R`d\x01a\x041V[P`\x01`\x01`\xA0\x1B\x03\x16_\x90\x81R`\x03` R`@\x90 T\x90V[```\x01\x80Ta\x030\x90a\x0C\xF7V[3_\x81\x81R`\x05` \x90\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x87\x16\x80\x85R\x90\x83R\x92\x81\x90 \x80T`\xFF\x19\x16\x86\x15\x15\x90\x81\x17\x90\x91U\x90Q\x90\x81R\x91\x92\x91\x7F\x170~\xAB9\xABa\x07\xE8\x89\x98E\xAD=Y\xBD\x96S\xF2\0\xF2 \x92\x04\x89\xCA+Y7il1\x91\x01`@Q\x80\x91\x03\x90\xA3PPV[a\t\"\x84\x84\x84a\x04\x95V[\x82;\x15\x80a\t\xABWP`@Qc\n\x85\xBD\x01`\xE1\x1B\x80\x82R\x90`\x01`\x01`\xA0\x1B\x03\x85\x16\x90c\x15\x0Bz\x02\x90a\t_\x903\x90\x89\x90\x88\x90\x88\x90`\x04\x01a\x0E\x96V[` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\t{W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\t\x9F\x91\x90a\rpV[`\x01`\x01`\xE0\x1B\x03\x19\x16\x14[a\t\xEAW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x10`$\x82\x01Ro\x15S\x94\xD0Q\x91W\xD4\x91P\xD2T\x12QS\x95`\x82\x1B`D\x82\x01R`d\x01a\x041V[PPPPV[`\x01`\x01`\xE0\x1B\x03\x19\x81\x16\x81\x14a\n\x05W_\x80\xFD[PV[_` \x82\x84\x03\x12\x15a\n\x18W_\x80\xFD[\x815a\n#\x81a\t\xF0V[\x93\x92PPPV[_\x81Q\x80\x84R\x80` \x84\x01` \x86\x01^_` \x82\x86\x01\x01R` `\x1F\x19`\x1F\x83\x01\x16\x85\x01\x01\x91PP\x92\x91PPV[` \x81R_a\n#` \x83\x01\x84a\n*V[_` \x82\x84\x03\x12\x15a\nzW_\x80\xFD[P5\x91\x90PV[\x805`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x087W_\x80\xFD[_\x80`@\x83\x85\x03\x12\x15a\n\xA8W_\x80\xFD[a\n\xB1\x83a\n\x81V[\x94` \x93\x90\x93\x015\x93PPPV[_\x80_``\x84\x86\x03\x12\x15a\n\xD1W_\x80\xFD[a\n\xDA\x84a\n\x81V[\x92Pa\n\xE8` \x85\x01a\n\x81V[\x91P`@\x84\x015\x90P\x92P\x92P\x92V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x84\x11\x15a\x0B&Wa\x0B&a\n\xF8V[`@Q`\x1F\x85\x01`\x1F\x19\x90\x81\x16`?\x01\x16\x81\x01\x90\x82\x82\x11\x81\x83\x10\x17\x15a\x0BNWa\x0BNa\n\xF8V[\x81`@R\x80\x93P\x85\x81R\x86\x86\x86\x01\x11\x15a\x0BfW_\x80\xFD[\x85\x85` \x83\x017_` \x87\x83\x01\x01RPPP\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a\x0B\x8EW_\x80\xFD[a\n#\x83\x835` \x85\x01a\x0B\x0CV[_\x80`@\x83\x85\x03\x12\x15a\x0B\xAEW_\x80\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15a\x0B\xC5W_\x80\xFD[a\x0B\xD1\x86\x83\x87\x01a\x0B\x7FV[\x93P` \x85\x015\x91P\x80\x82\x11\x15a\x0B\xE6W_\x80\xFD[Pa\x0B\xF3\x85\x82\x86\x01a\x0B\x7FV[\x91PP\x92P\x92\x90PV[_` \x82\x84\x03\x12\x15a\x0C\rW_\x80\xFD[a\n#\x82a\n\x81V[_\x80`@\x83\x85\x03\x12\x15a\x0C'W_\x80\xFD[a\x0C0\x83a\n\x81V[\x91P` \x83\x015\x80\x15\x15\x81\x14a\x0CDW_\x80\xFD[\x80\x91PP\x92P\x92\x90PV[_\x80_\x80`\x80\x85\x87\x03\x12\x15a\x0CbW_\x80\xFD[a\x0Ck\x85a\n\x81V[\x93Pa\x0Cy` \x86\x01a\n\x81V[\x92P`@\x85\x015\x91P``\x85\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x0C\x9BW_\x80\xFD[\x85\x01`\x1F\x81\x01\x87\x13a\x0C\xABW_\x80\xFD[a\x0C\xBA\x87\x825` \x84\x01a\x0B\x0CV[\x91PP\x92\x95\x91\x94P\x92PV[_\x80`@\x83\x85\x03\x12\x15a\x0C\xD7W_\x80\xFD[a\x0C\xE0\x83a\n\x81V[\x91Pa\x0C\xEE` \x84\x01a\n\x81V[\x90P\x92P\x92\x90PV[`\x01\x81\x81\x1C\x90\x82\x16\x80a\r\x0BW`\x7F\x82\x16\x91P[` \x82\x10\x81\x03a\r)WcNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[P\x91\x90PV[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[_\x81a\rQWa\rQa\r/V[P_\x19\x01\x90V[_`\x01\x82\x01a\riWa\ria\r/V[P`\x01\x01\x90V[_` \x82\x84\x03\x12\x15a\r\x80W_\x80\xFD[\x81Qa\n#\x81a\t\xF0V[`\x1F\x82\x11\x15a\x07nW\x80_R` _ `\x1F\x84\x01`\x05\x1C\x81\x01` \x85\x10\x15a\r\xB0WP\x80[`\x1F\x84\x01`\x05\x1C\x82\x01\x91P[\x81\x81\x10\x15a\r\xCFW_\x81U`\x01\x01a\r\xBCV[PPPPPV[\x81Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\r\xF0Wa\r\xF0a\n\xF8V[a\x0E\x04\x81a\r\xFE\x84Ta\x0C\xF7V[\x84a\r\x8BV[` \x80`\x1F\x83\x11`\x01\x81\x14a\x0E7W_\x84\x15a\x0E WP\x85\x83\x01Q[_\x19`\x03\x86\x90\x1B\x1C\x19\x16`\x01\x85\x90\x1B\x17\x85Ua\x0E\x8EV[_\x85\x81R` \x81 `\x1F\x19\x86\x16\x91[\x82\x81\x10\x15a\x0EeW\x88\x86\x01Q\x82U\x94\x84\x01\x94`\x01\x90\x91\x01\x90\x84\x01a\x0EFV[P\x85\x82\x10\x15a\x0E\x82W\x87\x85\x01Q_\x19`\x03\x88\x90\x1B`\xF8\x16\x1C\x19\x16\x81U[PP`\x01\x84`\x01\x1B\x01\x85U[PPPPPPV[`\x01`\x01`\xA0\x1B\x03\x85\x81\x16\x82R\x84\x16` \x82\x01R`@\x81\x01\x83\x90R`\x80``\x82\x01\x81\x90R_\x90a\x0E\xC8\x90\x83\x01\x84a\n*V[\x96\x95PPPPPPV\xFE\xA2dipfsX\"\x12 \xEA\xCC\xC2Z\xAD\xF8\xBCZ\xF3\xF85\xC0\xAC:4pO6\xE0+\xCC#\x8A\xB3\xF7\xD3\xC7E\xE1*\xFAUdsolcC\0\x08\x19\x003",
    );
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	/**Event with signature `Approval(address,address,uint256)` and selector `0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925`.
	```solidity
	event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);
	```*/
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
	#[derive(Clone)]
	pub struct Approval {
		#[allow(missing_docs)]
		pub _owner: alloy::sol_types::private::Address,
		#[allow(missing_docs)]
		pub _approved: alloy::sol_types::private::Address,
		#[allow(missing_docs)]
		pub _tokenId: alloy::sol_types::private::primitives::aliases::U256,
	}
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
	const _: () = {
		use alloy::sol_types as alloy_sol_types;
		#[automatically_derived]
		impl alloy_sol_types::SolEvent for Approval {
			type DataTuple<'a> = ();
			type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
			type TopicList = (
				alloy_sol_types::sol_data::FixedBytes<32>,
				alloy::sol_types::sol_data::Address,
				alloy::sol_types::sol_data::Address,
				alloy::sol_types::sol_data::Uint<256>,
			);
			const SIGNATURE: &'static str = "Approval(address,address,uint256)";
			const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
				140u8, 91u8, 225u8, 229u8, 235u8, 236u8, 125u8, 91u8, 209u8, 79u8, 113u8, 66u8, 125u8, 30u8, 132u8,
				243u8, 221u8, 3u8, 20u8, 192u8, 247u8, 178u8, 41u8, 30u8, 91u8, 32u8, 10u8, 200u8, 199u8, 195u8, 185u8,
				37u8,
			]);
			const ANONYMOUS: bool = false;
			#[allow(unused_variables)]
			#[inline]
			fn new(
				topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
				data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
			) -> Self {
				Self { _owner: topics.1, _approved: topics.2, _tokenId: topics.3 }
			}
			#[inline]
			fn check_signature(
				topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
			) -> alloy_sol_types::Result<()> {
				if topics.0 != Self::SIGNATURE_HASH {
					return Err(alloy_sol_types::Error::invalid_event_signature_hash(
						Self::SIGNATURE,
						topics.0,
						Self::SIGNATURE_HASH,
					));
				}
				Ok(())
			}
			#[inline]
			fn tokenize_body(&self) -> Self::DataToken<'_> {
				()
			}
			#[inline]
			fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
				(Self::SIGNATURE_HASH.into(), self._owner.clone(), self._approved.clone(), self._tokenId.clone())
			}
			#[inline]
			fn encode_topics_raw(
				&self,
				out: &mut [alloy_sol_types::abi::token::WordToken],
			) -> alloy_sol_types::Result<()> {
				if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
					return Err(alloy_sol_types::Error::Overrun);
				}
				out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
				out[1usize] =
					<alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(&self._owner);
				out[2usize] =
					<alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(&self._approved);
				out[3usize] = <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::EventTopic>::encode_topic(
					&self._tokenId,
				);
				Ok(())
			}
		}
		#[automatically_derived]
		impl alloy_sol_types::private::IntoLogData for Approval {
			fn to_log_data(&self) -> alloy_sol_types::private::LogData {
				From::from(self)
			}
			fn into_log_data(self) -> alloy_sol_types::private::LogData {
				From::from(&self)
			}
		}
		#[automatically_derived]
		impl From<&Approval> for alloy_sol_types::private::LogData {
			#[inline]
			fn from(this: &Approval) -> alloy_sol_types::private::LogData {
				alloy_sol_types::SolEvent::encode_log_data(this)
			}
		}
	};
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	/**Event with signature `ApprovalForAll(address,address,bool)` and selector `0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31`.
	```solidity
	event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);
	```*/
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
	#[derive(Clone)]
	pub struct ApprovalForAll {
		#[allow(missing_docs)]
		pub _owner: alloy::sol_types::private::Address,
		#[allow(missing_docs)]
		pub _operator: alloy::sol_types::private::Address,
		#[allow(missing_docs)]
		pub _approved: bool,
	}
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
	const _: () = {
		use alloy::sol_types as alloy_sol_types;
		#[automatically_derived]
		impl alloy_sol_types::SolEvent for ApprovalForAll {
			type DataTuple<'a> = (alloy::sol_types::sol_data::Bool,);
			type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
			type TopicList = (
				alloy_sol_types::sol_data::FixedBytes<32>,
				alloy::sol_types::sol_data::Address,
				alloy::sol_types::sol_data::Address,
			);
			const SIGNATURE: &'static str = "ApprovalForAll(address,address,bool)";
			const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
				23u8, 48u8, 126u8, 171u8, 57u8, 171u8, 97u8, 7u8, 232u8, 137u8, 152u8, 69u8, 173u8, 61u8, 89u8, 189u8,
				150u8, 83u8, 242u8, 0u8, 242u8, 32u8, 146u8, 4u8, 137u8, 202u8, 43u8, 89u8, 55u8, 105u8, 108u8, 49u8,
			]);
			const ANONYMOUS: bool = false;
			#[allow(unused_variables)]
			#[inline]
			fn new(
				topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
				data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
			) -> Self {
				Self { _owner: topics.1, _operator: topics.2, _approved: data.0 }
			}
			#[inline]
			fn check_signature(
				topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
			) -> alloy_sol_types::Result<()> {
				if topics.0 != Self::SIGNATURE_HASH {
					return Err(alloy_sol_types::Error::invalid_event_signature_hash(
						Self::SIGNATURE,
						topics.0,
						Self::SIGNATURE_HASH,
					));
				}
				Ok(())
			}
			#[inline]
			fn tokenize_body(&self) -> Self::DataToken<'_> {
				(<alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(&self._approved),)
			}
			#[inline]
			fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
				(Self::SIGNATURE_HASH.into(), self._owner.clone(), self._operator.clone())
			}
			#[inline]
			fn encode_topics_raw(
				&self,
				out: &mut [alloy_sol_types::abi::token::WordToken],
			) -> alloy_sol_types::Result<()> {
				if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
					return Err(alloy_sol_types::Error::Overrun);
				}
				out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
				out[1usize] =
					<alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(&self._owner);
				out[2usize] =
					<alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(&self._operator);
				Ok(())
			}
		}
		#[automatically_derived]
		impl alloy_sol_types::private::IntoLogData for ApprovalForAll {
			fn to_log_data(&self) -> alloy_sol_types::private::LogData {
				From::from(self)
			}
			fn into_log_data(self) -> alloy_sol_types::private::LogData {
				From::from(&self)
			}
		}
		#[automatically_derived]
		impl From<&ApprovalForAll> for alloy_sol_types::private::LogData {
			#[inline]
			fn from(this: &ApprovalForAll) -> alloy_sol_types::private::LogData {
				alloy_sol_types::SolEvent::encode_log_data(this)
			}
		}
	};
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	/**Event with signature `Transfer(address,address,uint256)` and selector `0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef`.
	```solidity
	event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);
	```*/
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
	#[derive(Clone)]
	pub struct Transfer {
		#[allow(missing_docs)]
		pub _from: alloy::sol_types::private::Address,
		#[allow(missing_docs)]
		pub _to: alloy::sol_types::private::Address,
		#[allow(missing_docs)]
		pub _tokenId: alloy::sol_types::private::primitives::aliases::U256,
	}
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
	const _: () = {
		use alloy::sol_types as alloy_sol_types;
		#[automatically_derived]
		impl alloy_sol_types::SolEvent for Transfer {
			type DataTuple<'a> = ();
			type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
			type TopicList = (
				alloy_sol_types::sol_data::FixedBytes<32>,
				alloy::sol_types::sol_data::Address,
				alloy::sol_types::sol_data::Address,
				alloy::sol_types::sol_data::Uint<256>,
			);
			const SIGNATURE: &'static str = "Transfer(address,address,uint256)";
			const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
				221u8, 242u8, 82u8, 173u8, 27u8, 226u8, 200u8, 155u8, 105u8, 194u8, 176u8, 104u8, 252u8, 55u8, 141u8,
				170u8, 149u8, 43u8, 167u8, 241u8, 99u8, 196u8, 161u8, 22u8, 40u8, 245u8, 90u8, 77u8, 245u8, 35u8,
				179u8, 239u8,
			]);
			const ANONYMOUS: bool = false;
			#[allow(unused_variables)]
			#[inline]
			fn new(
				topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
				data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
			) -> Self {
				Self { _from: topics.1, _to: topics.2, _tokenId: topics.3 }
			}
			#[inline]
			fn check_signature(
				topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
			) -> alloy_sol_types::Result<()> {
				if topics.0 != Self::SIGNATURE_HASH {
					return Err(alloy_sol_types::Error::invalid_event_signature_hash(
						Self::SIGNATURE,
						topics.0,
						Self::SIGNATURE_HASH,
					));
				}
				Ok(())
			}
			#[inline]
			fn tokenize_body(&self) -> Self::DataToken<'_> {
				()
			}
			#[inline]
			fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
				(Self::SIGNATURE_HASH.into(), self._from.clone(), self._to.clone(), self._tokenId.clone())
			}
			#[inline]
			fn encode_topics_raw(
				&self,
				out: &mut [alloy_sol_types::abi::token::WordToken],
			) -> alloy_sol_types::Result<()> {
				if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
					return Err(alloy_sol_types::Error::Overrun);
				}
				out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
				out[1usize] =
					<alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(&self._from);
				out[2usize] =
					<alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(&self._to);
				out[3usize] = <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::EventTopic>::encode_topic(
					&self._tokenId,
				);
				Ok(())
			}
		}
		#[automatically_derived]
		impl alloy_sol_types::private::IntoLogData for Transfer {
			fn to_log_data(&self) -> alloy_sol_types::private::LogData {
				From::from(self)
			}
			fn into_log_data(self) -> alloy_sol_types::private::LogData {
				From::from(&self)
			}
		}
		#[automatically_derived]
		impl From<&Transfer> for alloy_sol_types::private::LogData {
			#[inline]
			fn from(this: &Transfer) -> alloy_sol_types::private::LogData {
				alloy_sol_types::SolEvent::encode_log_data(this)
			}
		}
	};
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	/**Function with signature `approve(address,uint256)` and selector `0x095ea7b3`.
	```solidity
	function approve(address spender, uint256 id) external payable;
	```*/
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct approveCall {
		#[allow(missing_docs)]
		pub spender: alloy::sol_types::private::Address,
		#[allow(missing_docs)]
		pub id: alloy::sol_types::private::primitives::aliases::U256,
	}
	///Container type for the return parameters of the [`approve(address,uint256)`](approveCall) function.
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct approveReturn {}
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
	const _: () = {
		use alloy::sol_types as alloy_sol_types;
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::Uint<256>);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> =
				(alloy::sol_types::private::Address, alloy::sol_types::private::primitives::aliases::U256);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<approveCall> for UnderlyingRustTuple<'_> {
				fn from(value: approveCall) -> Self {
					(value.spender, value.id)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for approveCall {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self { spender: tuple.0, id: tuple.1 }
				}
			}
		}
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = ();
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = ();
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<approveReturn> for UnderlyingRustTuple<'_> {
				fn from(value: approveReturn) -> Self {
					()
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for approveReturn {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self {}
				}
			}
		}
		impl approveReturn {
			fn _tokenize(&self) -> <approveCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
				()
			}
		}
		#[automatically_derived]
		impl alloy_sol_types::SolCall for approveCall {
			type Parameters<'a> = (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::Uint<256>);
			type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
			type Return = approveReturn;
			type ReturnTuple<'a> = ();
			type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
			const SIGNATURE: &'static str = "approve(address,uint256)";
			const SELECTOR: [u8; 4] = [9u8, 94u8, 167u8, 179u8];
			#[inline]
			fn new<'a>(tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType) -> Self {
				tuple.into()
			}
			#[inline]
			fn tokenize(&self) -> Self::Token<'_> {
				(
					<alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(&self.spender),
					<alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(&self.id),
				)
			}
			#[inline]
			fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
				approveReturn::_tokenize(ret)
			}
			#[inline]
			fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(data).map(Into::into)
			}
			#[inline]
			fn abi_decode_returns_validate(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence_validate(data).map(Into::into)
			}
		}
	};
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	/**Function with signature `balanceOf(address)` and selector `0x70a08231`.
	```solidity
	function balanceOf(address owner) external view returns (uint256);
	```*/
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct balanceOfCall {
		#[allow(missing_docs)]
		pub owner: alloy::sol_types::private::Address,
	}
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	///Container type for the return parameters of the [`balanceOf(address)`](balanceOfCall) function.
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct balanceOfReturn {
		#[allow(missing_docs)]
		pub _0: alloy::sol_types::private::primitives::aliases::U256,
	}
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
	const _: () = {
		use alloy::sol_types as alloy_sol_types;
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<balanceOfCall> for UnderlyingRustTuple<'_> {
				fn from(value: balanceOfCall) -> Self {
					(value.owner,)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for balanceOfCall {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self { owner: tuple.0 }
				}
			}
		}
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<balanceOfReturn> for UnderlyingRustTuple<'_> {
				fn from(value: balanceOfReturn) -> Self {
					(value._0,)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for balanceOfReturn {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self { _0: tuple.0 }
				}
			}
		}
		#[automatically_derived]
		impl alloy_sol_types::SolCall for balanceOfCall {
			type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
			type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
			type Return = alloy::sol_types::private::primitives::aliases::U256;
			type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
			type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
			const SIGNATURE: &'static str = "balanceOf(address)";
			const SELECTOR: [u8; 4] = [112u8, 160u8, 130u8, 49u8];
			#[inline]
			fn new<'a>(tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType) -> Self {
				tuple.into()
			}
			#[inline]
			fn tokenize(&self) -> Self::Token<'_> {
				(<alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(&self.owner),)
			}
			#[inline]
			fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
				(<alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(ret),)
			}
			#[inline]
			fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(data).map(|r| {
					let r: balanceOfReturn = r.into();
					r._0
				})
			}
			#[inline]
			fn abi_decode_returns_validate(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence_validate(data).map(|r| {
					let r: balanceOfReturn = r.into();
					r._0
				})
			}
		}
	};
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	/**Function with signature `getApproved(uint256)` and selector `0x081812fc`.
	```solidity
	function getApproved(uint256 id) external view returns (address);
	```*/
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct getApprovedCall {
		#[allow(missing_docs)]
		pub id: alloy::sol_types::private::primitives::aliases::U256,
	}
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	///Container type for the return parameters of the [`getApproved(uint256)`](getApprovedCall) function.
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct getApprovedReturn {
		#[allow(missing_docs)]
		pub _0: alloy::sol_types::private::Address,
	}
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
	const _: () = {
		use alloy::sol_types as alloy_sol_types;
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<getApprovedCall> for UnderlyingRustTuple<'_> {
				fn from(value: getApprovedCall) -> Self {
					(value.id,)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for getApprovedCall {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self { id: tuple.0 }
				}
			}
		}
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<getApprovedReturn> for UnderlyingRustTuple<'_> {
				fn from(value: getApprovedReturn) -> Self {
					(value._0,)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for getApprovedReturn {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self { _0: tuple.0 }
				}
			}
		}
		#[automatically_derived]
		impl alloy_sol_types::SolCall for getApprovedCall {
			type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
			type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
			type Return = alloy::sol_types::private::Address;
			type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
			type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
			const SIGNATURE: &'static str = "getApproved(uint256)";
			const SELECTOR: [u8; 4] = [8u8, 24u8, 18u8, 252u8];
			#[inline]
			fn new<'a>(tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType) -> Self {
				tuple.into()
			}
			#[inline]
			fn tokenize(&self) -> Self::Token<'_> {
				(<alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(&self.id),)
			}
			#[inline]
			fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
				(<alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(ret),)
			}
			#[inline]
			fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(data).map(|r| {
					let r: getApprovedReturn = r.into();
					r._0
				})
			}
			#[inline]
			fn abi_decode_returns_validate(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence_validate(data).map(|r| {
					let r: getApprovedReturn = r.into();
					r._0
				})
			}
		}
	};
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	/**Function with signature `initialize(string,string)` and selector `0x4cd88b76`.
	```solidity
	function initialize(string memory name_, string memory symbol_) external;
	```*/
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct initializeCall {
		#[allow(missing_docs)]
		pub name_: alloy::sol_types::private::String,
		#[allow(missing_docs)]
		pub symbol_: alloy::sol_types::private::String,
	}
	///Container type for the return parameters of the [`initialize(string,string)`](initializeCall) function.
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct initializeReturn {}
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
	const _: () = {
		use alloy::sol_types as alloy_sol_types;
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String, alloy::sol_types::private::String);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<initializeCall> for UnderlyingRustTuple<'_> {
				fn from(value: initializeCall) -> Self {
					(value.name_, value.symbol_)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeCall {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self { name_: tuple.0, symbol_: tuple.1 }
				}
			}
		}
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = ();
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = ();
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<initializeReturn> for UnderlyingRustTuple<'_> {
				fn from(value: initializeReturn) -> Self {
					()
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeReturn {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self {}
				}
			}
		}
		impl initializeReturn {
			fn _tokenize(&self) -> <initializeCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
				()
			}
		}
		#[automatically_derived]
		impl alloy_sol_types::SolCall for initializeCall {
			type Parameters<'a> = (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
			type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
			type Return = initializeReturn;
			type ReturnTuple<'a> = ();
			type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
			const SIGNATURE: &'static str = "initialize(string,string)";
			const SELECTOR: [u8; 4] = [76u8, 216u8, 139u8, 118u8];
			#[inline]
			fn new<'a>(tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType) -> Self {
				tuple.into()
			}
			#[inline]
			fn tokenize(&self) -> Self::Token<'_> {
				(
					<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(&self.name_),
					<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(&self.symbol_),
				)
			}
			#[inline]
			fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
				initializeReturn::_tokenize(ret)
			}
			#[inline]
			fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(data).map(Into::into)
			}
			#[inline]
			fn abi_decode_returns_validate(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence_validate(data).map(Into::into)
			}
		}
	};
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	/**Function with signature `isApprovedForAll(address,address)` and selector `0xe985e9c5`.
	```solidity
	function isApprovedForAll(address owner, address operator) external view returns (bool);
	```*/
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct isApprovedForAllCall {
		#[allow(missing_docs)]
		pub owner: alloy::sol_types::private::Address,
		#[allow(missing_docs)]
		pub operator: alloy::sol_types::private::Address,
	}
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	///Container type for the return parameters of the [`isApprovedForAll(address,address)`](isApprovedForAllCall) function.
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct isApprovedForAllReturn {
		#[allow(missing_docs)]
		pub _0: bool,
	}
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
	const _: () = {
		use alloy::sol_types as alloy_sol_types;
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::Address);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, alloy::sol_types::private::Address);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<isApprovedForAllCall> for UnderlyingRustTuple<'_> {
				fn from(value: isApprovedForAllCall) -> Self {
					(value.owner, value.operator)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for isApprovedForAllCall {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self { owner: tuple.0, operator: tuple.1 }
				}
			}
		}
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = (bool,);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<isApprovedForAllReturn> for UnderlyingRustTuple<'_> {
				fn from(value: isApprovedForAllReturn) -> Self {
					(value._0,)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for isApprovedForAllReturn {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self { _0: tuple.0 }
				}
			}
		}
		#[automatically_derived]
		impl alloy_sol_types::SolCall for isApprovedForAllCall {
			type Parameters<'a> = (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::Address);
			type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
			type Return = bool;
			type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
			type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
			const SIGNATURE: &'static str = "isApprovedForAll(address,address)";
			const SELECTOR: [u8; 4] = [233u8, 133u8, 233u8, 197u8];
			#[inline]
			fn new<'a>(tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType) -> Self {
				tuple.into()
			}
			#[inline]
			fn tokenize(&self) -> Self::Token<'_> {
				(
					<alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(&self.owner),
					<alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(&self.operator),
				)
			}
			#[inline]
			fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
				(<alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(ret),)
			}
			#[inline]
			fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(data).map(|r| {
					let r: isApprovedForAllReturn = r.into();
					r._0
				})
			}
			#[inline]
			fn abi_decode_returns_validate(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence_validate(data).map(|r| {
					let r: isApprovedForAllReturn = r.into();
					r._0
				})
			}
		}
	};
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	/**Function with signature `name()` and selector `0x06fdde03`.
	```solidity
	function name() external view returns (string memory);
	```*/
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct nameCall;
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	///Container type for the return parameters of the [`name()`](nameCall) function.
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct nameReturn {
		#[allow(missing_docs)]
		pub _0: alloy::sol_types::private::String,
	}
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
	const _: () = {
		use alloy::sol_types as alloy_sol_types;
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = ();
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = ();
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<nameCall> for UnderlyingRustTuple<'_> {
				fn from(value: nameCall) -> Self {
					()
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for nameCall {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self
				}
			}
		}
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<nameReturn> for UnderlyingRustTuple<'_> {
				fn from(value: nameReturn) -> Self {
					(value._0,)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for nameReturn {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self { _0: tuple.0 }
				}
			}
		}
		#[automatically_derived]
		impl alloy_sol_types::SolCall for nameCall {
			type Parameters<'a> = ();
			type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
			type Return = alloy::sol_types::private::String;
			type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
			type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
			const SIGNATURE: &'static str = "name()";
			const SELECTOR: [u8; 4] = [6u8, 253u8, 222u8, 3u8];
			#[inline]
			fn new<'a>(tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType) -> Self {
				tuple.into()
			}
			#[inline]
			fn tokenize(&self) -> Self::Token<'_> {
				()
			}
			#[inline]
			fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
				(<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(ret),)
			}
			#[inline]
			fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(data).map(|r| {
					let r: nameReturn = r.into();
					r._0
				})
			}
			#[inline]
			fn abi_decode_returns_validate(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence_validate(data).map(|r| {
					let r: nameReturn = r.into();
					r._0
				})
			}
		}
	};
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	/**Function with signature `ownerOf(uint256)` and selector `0x6352211e`.
	```solidity
	function ownerOf(uint256 id) external view returns (address owner);
	```*/
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct ownerOfCall {
		#[allow(missing_docs)]
		pub id: alloy::sol_types::private::primitives::aliases::U256,
	}
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	///Container type for the return parameters of the [`ownerOf(uint256)`](ownerOfCall) function.
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct ownerOfReturn {
		#[allow(missing_docs)]
		pub owner: alloy::sol_types::private::Address,
	}
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
	const _: () = {
		use alloy::sol_types as alloy_sol_types;
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<ownerOfCall> for UnderlyingRustTuple<'_> {
				fn from(value: ownerOfCall) -> Self {
					(value.id,)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerOfCall {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self { id: tuple.0 }
				}
			}
		}
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<ownerOfReturn> for UnderlyingRustTuple<'_> {
				fn from(value: ownerOfReturn) -> Self {
					(value.owner,)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerOfReturn {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self { owner: tuple.0 }
				}
			}
		}
		#[automatically_derived]
		impl alloy_sol_types::SolCall for ownerOfCall {
			type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
			type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
			type Return = alloy::sol_types::private::Address;
			type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
			type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
			const SIGNATURE: &'static str = "ownerOf(uint256)";
			const SELECTOR: [u8; 4] = [99u8, 82u8, 33u8, 30u8];
			#[inline]
			fn new<'a>(tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType) -> Self {
				tuple.into()
			}
			#[inline]
			fn tokenize(&self) -> Self::Token<'_> {
				(<alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(&self.id),)
			}
			#[inline]
			fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
				(<alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(ret),)
			}
			#[inline]
			fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(data).map(|r| {
					let r: ownerOfReturn = r.into();
					r.owner
				})
			}
			#[inline]
			fn abi_decode_returns_validate(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence_validate(data).map(|r| {
					let r: ownerOfReturn = r.into();
					r.owner
				})
			}
		}
	};
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	/**Function with signature `safeTransferFrom(address,address,uint256)` and selector `0x42842e0e`.
	```solidity
	function safeTransferFrom(address from, address to, uint256 id) external payable;
	```*/
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct safeTransferFrom_0Call {
		#[allow(missing_docs)]
		pub from: alloy::sol_types::private::Address,
		#[allow(missing_docs)]
		pub to: alloy::sol_types::private::Address,
		#[allow(missing_docs)]
		pub id: alloy::sol_types::private::primitives::aliases::U256,
	}
	///Container type for the return parameters of the [`safeTransferFrom(address,address,uint256)`](safeTransferFrom_0Call) function.
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct safeTransferFrom_0Return {}
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
	const _: () = {
		use alloy::sol_types as alloy_sol_types;
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (
				alloy::sol_types::sol_data::Address,
				alloy::sol_types::sol_data::Address,
				alloy::sol_types::sol_data::Uint<256>,
			);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = (
				alloy::sol_types::private::Address,
				alloy::sol_types::private::Address,
				alloy::sol_types::private::primitives::aliases::U256,
			);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<safeTransferFrom_0Call> for UnderlyingRustTuple<'_> {
				fn from(value: safeTransferFrom_0Call) -> Self {
					(value.from, value.to, value.id)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for safeTransferFrom_0Call {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self { from: tuple.0, to: tuple.1, id: tuple.2 }
				}
			}
		}
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = ();
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = ();
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<safeTransferFrom_0Return> for UnderlyingRustTuple<'_> {
				fn from(value: safeTransferFrom_0Return) -> Self {
					()
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for safeTransferFrom_0Return {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self {}
				}
			}
		}
		impl safeTransferFrom_0Return {
			fn _tokenize(&self) -> <safeTransferFrom_0Call as alloy_sol_types::SolCall>::ReturnToken<'_> {
				()
			}
		}
		#[automatically_derived]
		impl alloy_sol_types::SolCall for safeTransferFrom_0Call {
			type Parameters<'a> = (
				alloy::sol_types::sol_data::Address,
				alloy::sol_types::sol_data::Address,
				alloy::sol_types::sol_data::Uint<256>,
			);
			type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
			type Return = safeTransferFrom_0Return;
			type ReturnTuple<'a> = ();
			type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
			const SIGNATURE: &'static str = "safeTransferFrom(address,address,uint256)";
			const SELECTOR: [u8; 4] = [66u8, 132u8, 46u8, 14u8];
			#[inline]
			fn new<'a>(tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType) -> Self {
				tuple.into()
			}
			#[inline]
			fn tokenize(&self) -> Self::Token<'_> {
				(
					<alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(&self.from),
					<alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(&self.to),
					<alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(&self.id),
				)
			}
			#[inline]
			fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
				safeTransferFrom_0Return::_tokenize(ret)
			}
			#[inline]
			fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(data).map(Into::into)
			}
			#[inline]
			fn abi_decode_returns_validate(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence_validate(data).map(Into::into)
			}
		}
	};
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	/**Function with signature `safeTransferFrom(address,address,uint256,bytes)` and selector `0xb88d4fde`.
	```solidity
	function safeTransferFrom(address from, address to, uint256 id, bytes memory data) external payable;
	```*/
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct safeTransferFrom_1Call {
		#[allow(missing_docs)]
		pub from: alloy::sol_types::private::Address,
		#[allow(missing_docs)]
		pub to: alloy::sol_types::private::Address,
		#[allow(missing_docs)]
		pub id: alloy::sol_types::private::primitives::aliases::U256,
		#[allow(missing_docs)]
		pub data: alloy::sol_types::private::Bytes,
	}
	///Container type for the return parameters of the [`safeTransferFrom(address,address,uint256,bytes)`](safeTransferFrom_1Call) function.
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct safeTransferFrom_1Return {}
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
	const _: () = {
		use alloy::sol_types as alloy_sol_types;
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (
				alloy::sol_types::sol_data::Address,
				alloy::sol_types::sol_data::Address,
				alloy::sol_types::sol_data::Uint<256>,
				alloy::sol_types::sol_data::Bytes,
			);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = (
				alloy::sol_types::private::Address,
				alloy::sol_types::private::Address,
				alloy::sol_types::private::primitives::aliases::U256,
				alloy::sol_types::private::Bytes,
			);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<safeTransferFrom_1Call> for UnderlyingRustTuple<'_> {
				fn from(value: safeTransferFrom_1Call) -> Self {
					(value.from, value.to, value.id, value.data)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for safeTransferFrom_1Call {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self { from: tuple.0, to: tuple.1, id: tuple.2, data: tuple.3 }
				}
			}
		}
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = ();
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = ();
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<safeTransferFrom_1Return> for UnderlyingRustTuple<'_> {
				fn from(value: safeTransferFrom_1Return) -> Self {
					()
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for safeTransferFrom_1Return {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self {}
				}
			}
		}
		impl safeTransferFrom_1Return {
			fn _tokenize(&self) -> <safeTransferFrom_1Call as alloy_sol_types::SolCall>::ReturnToken<'_> {
				()
			}
		}
		#[automatically_derived]
		impl alloy_sol_types::SolCall for safeTransferFrom_1Call {
			type Parameters<'a> = (
				alloy::sol_types::sol_data::Address,
				alloy::sol_types::sol_data::Address,
				alloy::sol_types::sol_data::Uint<256>,
				alloy::sol_types::sol_data::Bytes,
			);
			type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
			type Return = safeTransferFrom_1Return;
			type ReturnTuple<'a> = ();
			type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
			const SIGNATURE: &'static str = "safeTransferFrom(address,address,uint256,bytes)";
			const SELECTOR: [u8; 4] = [184u8, 141u8, 79u8, 222u8];
			#[inline]
			fn new<'a>(tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType) -> Self {
				tuple.into()
			}
			#[inline]
			fn tokenize(&self) -> Self::Token<'_> {
				(
					<alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(&self.from),
					<alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(&self.to),
					<alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(&self.id),
					<alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(&self.data),
				)
			}
			#[inline]
			fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
				safeTransferFrom_1Return::_tokenize(ret)
			}
			#[inline]
			fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(data).map(Into::into)
			}
			#[inline]
			fn abi_decode_returns_validate(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence_validate(data).map(Into::into)
			}
		}
	};
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	/**Function with signature `setApprovalForAll(address,bool)` and selector `0xa22cb465`.
	```solidity
	function setApprovalForAll(address operator, bool approved) external;
	```*/
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct setApprovalForAllCall {
		#[allow(missing_docs)]
		pub operator: alloy::sol_types::private::Address,
		#[allow(missing_docs)]
		pub approved: bool,
	}
	///Container type for the return parameters of the [`setApprovalForAll(address,bool)`](setApprovalForAllCall) function.
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct setApprovalForAllReturn {}
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
	const _: () = {
		use alloy::sol_types as alloy_sol_types;
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::Bool);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, bool);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<setApprovalForAllCall> for UnderlyingRustTuple<'_> {
				fn from(value: setApprovalForAllCall) -> Self {
					(value.operator, value.approved)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for setApprovalForAllCall {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self { operator: tuple.0, approved: tuple.1 }
				}
			}
		}
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = ();
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = ();
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<setApprovalForAllReturn> for UnderlyingRustTuple<'_> {
				fn from(value: setApprovalForAllReturn) -> Self {
					()
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for setApprovalForAllReturn {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self {}
				}
			}
		}
		impl setApprovalForAllReturn {
			fn _tokenize(&self) -> <setApprovalForAllCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
				()
			}
		}
		#[automatically_derived]
		impl alloy_sol_types::SolCall for setApprovalForAllCall {
			type Parameters<'a> = (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::Bool);
			type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
			type Return = setApprovalForAllReturn;
			type ReturnTuple<'a> = ();
			type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
			const SIGNATURE: &'static str = "setApprovalForAll(address,bool)";
			const SELECTOR: [u8; 4] = [162u8, 44u8, 180u8, 101u8];
			#[inline]
			fn new<'a>(tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType) -> Self {
				tuple.into()
			}
			#[inline]
			fn tokenize(&self) -> Self::Token<'_> {
				(
					<alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(&self.operator),
					<alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(&self.approved),
				)
			}
			#[inline]
			fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
				setApprovalForAllReturn::_tokenize(ret)
			}
			#[inline]
			fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(data).map(Into::into)
			}
			#[inline]
			fn abi_decode_returns_validate(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence_validate(data).map(Into::into)
			}
		}
	};
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	/**Function with signature `supportsInterface(bytes4)` and selector `0x01ffc9a7`.
	```solidity
	function supportsInterface(bytes4 interfaceId) external view returns (bool);
	```*/
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct supportsInterfaceCall {
		#[allow(missing_docs)]
		pub interfaceId: alloy::sol_types::private::FixedBytes<4>,
	}
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	///Container type for the return parameters of the [`supportsInterface(bytes4)`](supportsInterfaceCall) function.
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct supportsInterfaceReturn {
		#[allow(missing_docs)]
		pub _0: bool,
	}
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
	const _: () = {
		use alloy::sol_types as alloy_sol_types;
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<4>,);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<supportsInterfaceCall> for UnderlyingRustTuple<'_> {
				fn from(value: supportsInterfaceCall) -> Self {
					(value.interfaceId,)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for supportsInterfaceCall {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self { interfaceId: tuple.0 }
				}
			}
		}
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = (bool,);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<supportsInterfaceReturn> for UnderlyingRustTuple<'_> {
				fn from(value: supportsInterfaceReturn) -> Self {
					(value._0,)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for supportsInterfaceReturn {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self { _0: tuple.0 }
				}
			}
		}
		#[automatically_derived]
		impl alloy_sol_types::SolCall for supportsInterfaceCall {
			type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
			type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
			type Return = bool;
			type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
			type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
			const SIGNATURE: &'static str = "supportsInterface(bytes4)";
			const SELECTOR: [u8; 4] = [1u8, 255u8, 201u8, 167u8];
			#[inline]
			fn new<'a>(tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType) -> Self {
				tuple.into()
			}
			#[inline]
			fn tokenize(&self) -> Self::Token<'_> {
				(<alloy::sol_types::sol_data::FixedBytes<4> as alloy_sol_types::SolType>::tokenize(&self.interfaceId),)
			}
			#[inline]
			fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
				(<alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(ret),)
			}
			#[inline]
			fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(data).map(|r| {
					let r: supportsInterfaceReturn = r.into();
					r._0
				})
			}
			#[inline]
			fn abi_decode_returns_validate(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence_validate(data).map(|r| {
					let r: supportsInterfaceReturn = r.into();
					r._0
				})
			}
		}
	};
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	/**Function with signature `symbol()` and selector `0x95d89b41`.
	```solidity
	function symbol() external view returns (string memory);
	```*/
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct symbolCall;
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	///Container type for the return parameters of the [`symbol()`](symbolCall) function.
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct symbolReturn {
		#[allow(missing_docs)]
		pub _0: alloy::sol_types::private::String,
	}
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
	const _: () = {
		use alloy::sol_types as alloy_sol_types;
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = ();
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = ();
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<symbolCall> for UnderlyingRustTuple<'_> {
				fn from(value: symbolCall) -> Self {
					()
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for symbolCall {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self
				}
			}
		}
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<symbolReturn> for UnderlyingRustTuple<'_> {
				fn from(value: symbolReturn) -> Self {
					(value._0,)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for symbolReturn {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self { _0: tuple.0 }
				}
			}
		}
		#[automatically_derived]
		impl alloy_sol_types::SolCall for symbolCall {
			type Parameters<'a> = ();
			type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
			type Return = alloy::sol_types::private::String;
			type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
			type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
			const SIGNATURE: &'static str = "symbol()";
			const SELECTOR: [u8; 4] = [149u8, 216u8, 155u8, 65u8];
			#[inline]
			fn new<'a>(tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType) -> Self {
				tuple.into()
			}
			#[inline]
			fn tokenize(&self) -> Self::Token<'_> {
				()
			}
			#[inline]
			fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
				(<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(ret),)
			}
			#[inline]
			fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(data).map(|r| {
					let r: symbolReturn = r.into();
					r._0
				})
			}
			#[inline]
			fn abi_decode_returns_validate(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence_validate(data).map(|r| {
					let r: symbolReturn = r.into();
					r._0
				})
			}
		}
	};
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	/**Function with signature `tokenURI(uint256)` and selector `0xc87b56dd`.
	```solidity
	function tokenURI(uint256 id) external view returns (string memory);
	```*/
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct tokenURICall {
		#[allow(missing_docs)]
		pub id: alloy::sol_types::private::primitives::aliases::U256,
	}
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	///Container type for the return parameters of the [`tokenURI(uint256)`](tokenURICall) function.
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct tokenURIReturn {
		#[allow(missing_docs)]
		pub _0: alloy::sol_types::private::String,
	}
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
	const _: () = {
		use alloy::sol_types as alloy_sol_types;
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<tokenURICall> for UnderlyingRustTuple<'_> {
				fn from(value: tokenURICall) -> Self {
					(value.id,)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for tokenURICall {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self { id: tuple.0 }
				}
			}
		}
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<tokenURIReturn> for UnderlyingRustTuple<'_> {
				fn from(value: tokenURIReturn) -> Self {
					(value._0,)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for tokenURIReturn {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self { _0: tuple.0 }
				}
			}
		}
		#[automatically_derived]
		impl alloy_sol_types::SolCall for tokenURICall {
			type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
			type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
			type Return = alloy::sol_types::private::String;
			type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
			type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
			const SIGNATURE: &'static str = "tokenURI(uint256)";
			const SELECTOR: [u8; 4] = [200u8, 123u8, 86u8, 221u8];
			#[inline]
			fn new<'a>(tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType) -> Self {
				tuple.into()
			}
			#[inline]
			fn tokenize(&self) -> Self::Token<'_> {
				(<alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(&self.id),)
			}
			#[inline]
			fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
				(<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(ret),)
			}
			#[inline]
			fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(data).map(|r| {
					let r: tokenURIReturn = r.into();
					r._0
				})
			}
			#[inline]
			fn abi_decode_returns_validate(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence_validate(data).map(|r| {
					let r: tokenURIReturn = r.into();
					r._0
				})
			}
		}
	};
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	/**Function with signature `transferFrom(address,address,uint256)` and selector `0x23b872dd`.
	```solidity
	function transferFrom(address from, address to, uint256 id) external payable;
	```*/
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct transferFromCall {
		#[allow(missing_docs)]
		pub from: alloy::sol_types::private::Address,
		#[allow(missing_docs)]
		pub to: alloy::sol_types::private::Address,
		#[allow(missing_docs)]
		pub id: alloy::sol_types::private::primitives::aliases::U256,
	}
	///Container type for the return parameters of the [`transferFrom(address,address,uint256)`](transferFromCall) function.
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct transferFromReturn {}
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
	const _: () = {
		use alloy::sol_types as alloy_sol_types;
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (
				alloy::sol_types::sol_data::Address,
				alloy::sol_types::sol_data::Address,
				alloy::sol_types::sol_data::Uint<256>,
			);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = (
				alloy::sol_types::private::Address,
				alloy::sol_types::private::Address,
				alloy::sol_types::private::primitives::aliases::U256,
			);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<transferFromCall> for UnderlyingRustTuple<'_> {
				fn from(value: transferFromCall) -> Self {
					(value.from, value.to, value.id)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferFromCall {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self { from: tuple.0, to: tuple.1, id: tuple.2 }
				}
			}
		}
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = ();
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = ();
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<transferFromReturn> for UnderlyingRustTuple<'_> {
				fn from(value: transferFromReturn) -> Self {
					()
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferFromReturn {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self {}
				}
			}
		}
		impl transferFromReturn {
			fn _tokenize(&self) -> <transferFromCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
				()
			}
		}
		#[automatically_derived]
		impl alloy_sol_types::SolCall for transferFromCall {
			type Parameters<'a> = (
				alloy::sol_types::sol_data::Address,
				alloy::sol_types::sol_data::Address,
				alloy::sol_types::sol_data::Uint<256>,
			);
			type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
			type Return = transferFromReturn;
			type ReturnTuple<'a> = ();
			type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
			const SIGNATURE: &'static str = "transferFrom(address,address,uint256)";
			const SELECTOR: [u8; 4] = [35u8, 184u8, 114u8, 221u8];
			#[inline]
			fn new<'a>(tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType) -> Self {
				tuple.into()
			}
			#[inline]
			fn tokenize(&self) -> Self::Token<'_> {
				(
					<alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(&self.from),
					<alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(&self.to),
					<alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(&self.id),
				)
			}
			#[inline]
			fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
				transferFromReturn::_tokenize(ret)
			}
			#[inline]
			fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(data).map(Into::into)
			}
			#[inline]
			fn abi_decode_returns_validate(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence_validate(data).map(Into::into)
			}
		}
	};
	///Container for all the [`MockERC721`](self) function calls.
	#[derive(Clone, serde::Serialize, serde::Deserialize)]
	pub enum MockERC721Calls {
		#[allow(missing_docs)]
		approve(approveCall),
		#[allow(missing_docs)]
		balanceOf(balanceOfCall),
		#[allow(missing_docs)]
		getApproved(getApprovedCall),
		#[allow(missing_docs)]
		initialize(initializeCall),
		#[allow(missing_docs)]
		isApprovedForAll(isApprovedForAllCall),
		#[allow(missing_docs)]
		name(nameCall),
		#[allow(missing_docs)]
		ownerOf(ownerOfCall),
		#[allow(missing_docs)]
		safeTransferFrom_0(safeTransferFrom_0Call),
		#[allow(missing_docs)]
		safeTransferFrom_1(safeTransferFrom_1Call),
		#[allow(missing_docs)]
		setApprovalForAll(setApprovalForAllCall),
		#[allow(missing_docs)]
		supportsInterface(supportsInterfaceCall),
		#[allow(missing_docs)]
		symbol(symbolCall),
		#[allow(missing_docs)]
		tokenURI(tokenURICall),
		#[allow(missing_docs)]
		transferFrom(transferFromCall),
	}
	impl MockERC721Calls {
		/// All the selectors of this enum.
		///
		/// Note that the selectors might not be in the same order as the variants.
		/// No guarantees are made about the order of the selectors.
		///
		/// Prefer using `SolInterface` methods instead.
		pub const SELECTORS: &'static [[u8; 4usize]] = &[
			[1u8, 255u8, 201u8, 167u8],
			[6u8, 253u8, 222u8, 3u8],
			[8u8, 24u8, 18u8, 252u8],
			[9u8, 94u8, 167u8, 179u8],
			[35u8, 184u8, 114u8, 221u8],
			[66u8, 132u8, 46u8, 14u8],
			[76u8, 216u8, 139u8, 118u8],
			[99u8, 82u8, 33u8, 30u8],
			[112u8, 160u8, 130u8, 49u8],
			[149u8, 216u8, 155u8, 65u8],
			[162u8, 44u8, 180u8, 101u8],
			[184u8, 141u8, 79u8, 222u8],
			[200u8, 123u8, 86u8, 221u8],
			[233u8, 133u8, 233u8, 197u8],
		];
		/// The names of the variants in the same order as `SELECTORS`.
		pub const VARIANT_NAMES: &'static [&'static str] = &[
			::core::stringify!(supportsInterface),
			::core::stringify!(name),
			::core::stringify!(getApproved),
			::core::stringify!(approve),
			::core::stringify!(transferFrom),
			::core::stringify!(safeTransferFrom_0),
			::core::stringify!(initialize),
			::core::stringify!(ownerOf),
			::core::stringify!(balanceOf),
			::core::stringify!(symbol),
			::core::stringify!(setApprovalForAll),
			::core::stringify!(safeTransferFrom_1),
			::core::stringify!(tokenURI),
			::core::stringify!(isApprovedForAll),
		];
		/// The signatures in the same order as `SELECTORS`.
		pub const SIGNATURES: &'static [&'static str] = &[
			<supportsInterfaceCall as alloy_sol_types::SolCall>::SIGNATURE,
			<nameCall as alloy_sol_types::SolCall>::SIGNATURE,
			<getApprovedCall as alloy_sol_types::SolCall>::SIGNATURE,
			<approveCall as alloy_sol_types::SolCall>::SIGNATURE,
			<transferFromCall as alloy_sol_types::SolCall>::SIGNATURE,
			<safeTransferFrom_0Call as alloy_sol_types::SolCall>::SIGNATURE,
			<initializeCall as alloy_sol_types::SolCall>::SIGNATURE,
			<ownerOfCall as alloy_sol_types::SolCall>::SIGNATURE,
			<balanceOfCall as alloy_sol_types::SolCall>::SIGNATURE,
			<symbolCall as alloy_sol_types::SolCall>::SIGNATURE,
			<setApprovalForAllCall as alloy_sol_types::SolCall>::SIGNATURE,
			<safeTransferFrom_1Call as alloy_sol_types::SolCall>::SIGNATURE,
			<tokenURICall as alloy_sol_types::SolCall>::SIGNATURE,
			<isApprovedForAllCall as alloy_sol_types::SolCall>::SIGNATURE,
		];
		/// Returns the signature for the given selector, if known.
		#[inline]
		pub fn signature_by_selector(selector: [u8; 4usize]) -> ::core::option::Option<&'static str> {
			match Self::SELECTORS.binary_search(&selector) {
				::core::result::Result::Ok(idx) => ::core::option::Option::Some(Self::SIGNATURES[idx]),
				::core::result::Result::Err(_) => ::core::option::Option::None,
			}
		}
		/// Returns the enum variant name for the given selector, if known.
		#[inline]
		pub fn name_by_selector(selector: [u8; 4usize]) -> ::core::option::Option<&'static str> {
			let sig = Self::signature_by_selector(selector)?;
			sig.split_once('(').map(|(name, _)| name)
		}
	}
	#[automatically_derived]
	impl alloy_sol_types::SolInterface for MockERC721Calls {
		const NAME: &'static str = "MockERC721Calls";
		const MIN_DATA_LENGTH: usize = 0usize;
		const COUNT: usize = 14usize;
		#[inline]
		fn selector(&self) -> [u8; 4] {
			match self {
				Self::approve(_) => <approveCall as alloy_sol_types::SolCall>::SELECTOR,
				Self::balanceOf(_) => <balanceOfCall as alloy_sol_types::SolCall>::SELECTOR,
				Self::getApproved(_) => <getApprovedCall as alloy_sol_types::SolCall>::SELECTOR,
				Self::initialize(_) => <initializeCall as alloy_sol_types::SolCall>::SELECTOR,
				Self::isApprovedForAll(_) => <isApprovedForAllCall as alloy_sol_types::SolCall>::SELECTOR,
				Self::name(_) => <nameCall as alloy_sol_types::SolCall>::SELECTOR,
				Self::ownerOf(_) => <ownerOfCall as alloy_sol_types::SolCall>::SELECTOR,
				Self::safeTransferFrom_0(_) => <safeTransferFrom_0Call as alloy_sol_types::SolCall>::SELECTOR,
				Self::safeTransferFrom_1(_) => <safeTransferFrom_1Call as alloy_sol_types::SolCall>::SELECTOR,
				Self::setApprovalForAll(_) => <setApprovalForAllCall as alloy_sol_types::SolCall>::SELECTOR,
				Self::supportsInterface(_) => <supportsInterfaceCall as alloy_sol_types::SolCall>::SELECTOR,
				Self::symbol(_) => <symbolCall as alloy_sol_types::SolCall>::SELECTOR,
				Self::tokenURI(_) => <tokenURICall as alloy_sol_types::SolCall>::SELECTOR,
				Self::transferFrom(_) => <transferFromCall as alloy_sol_types::SolCall>::SELECTOR,
			}
		}
		#[inline]
		fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
			Self::SELECTORS.get(i).copied()
		}
		#[inline]
		fn valid_selector(selector: [u8; 4]) -> bool {
			Self::SELECTORS.binary_search(&selector).is_ok()
		}
		#[inline]
		#[allow(non_snake_case)]
		fn abi_decode_raw(selector: [u8; 4], data: &[u8]) -> alloy_sol_types::Result<Self> {
			static DECODE_SHIMS: &[fn(&[u8]) -> alloy_sol_types::Result<MockERC721Calls>] = &[
				{
					fn supportsInterface(data: &[u8]) -> alloy_sol_types::Result<MockERC721Calls> {
						<supportsInterfaceCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
							.map(MockERC721Calls::supportsInterface)
					}
					supportsInterface
				},
				{
					fn name(data: &[u8]) -> alloy_sol_types::Result<MockERC721Calls> {
						<nameCall as alloy_sol_types::SolCall>::abi_decode_raw(data).map(MockERC721Calls::name)
					}
					name
				},
				{
					fn getApproved(data: &[u8]) -> alloy_sol_types::Result<MockERC721Calls> {
						<getApprovedCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
							.map(MockERC721Calls::getApproved)
					}
					getApproved
				},
				{
					fn approve(data: &[u8]) -> alloy_sol_types::Result<MockERC721Calls> {
						<approveCall as alloy_sol_types::SolCall>::abi_decode_raw(data).map(MockERC721Calls::approve)
					}
					approve
				},
				{
					fn transferFrom(data: &[u8]) -> alloy_sol_types::Result<MockERC721Calls> {
						<transferFromCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
							.map(MockERC721Calls::transferFrom)
					}
					transferFrom
				},
				{
					fn safeTransferFrom_0(data: &[u8]) -> alloy_sol_types::Result<MockERC721Calls> {
						<safeTransferFrom_0Call as alloy_sol_types::SolCall>::abi_decode_raw(data)
							.map(MockERC721Calls::safeTransferFrom_0)
					}
					safeTransferFrom_0
				},
				{
					fn initialize(data: &[u8]) -> alloy_sol_types::Result<MockERC721Calls> {
						<initializeCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
							.map(MockERC721Calls::initialize)
					}
					initialize
				},
				{
					fn ownerOf(data: &[u8]) -> alloy_sol_types::Result<MockERC721Calls> {
						<ownerOfCall as alloy_sol_types::SolCall>::abi_decode_raw(data).map(MockERC721Calls::ownerOf)
					}
					ownerOf
				},
				{
					fn balanceOf(data: &[u8]) -> alloy_sol_types::Result<MockERC721Calls> {
						<balanceOfCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
							.map(MockERC721Calls::balanceOf)
					}
					balanceOf
				},
				{
					fn symbol(data: &[u8]) -> alloy_sol_types::Result<MockERC721Calls> {
						<symbolCall as alloy_sol_types::SolCall>::abi_decode_raw(data).map(MockERC721Calls::symbol)
					}
					symbol
				},
				{
					fn setApprovalForAll(data: &[u8]) -> alloy_sol_types::Result<MockERC721Calls> {
						<setApprovalForAllCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
							.map(MockERC721Calls::setApprovalForAll)
					}
					setApprovalForAll
				},
				{
					fn safeTransferFrom_1(data: &[u8]) -> alloy_sol_types::Result<MockERC721Calls> {
						<safeTransferFrom_1Call as alloy_sol_types::SolCall>::abi_decode_raw(data)
							.map(MockERC721Calls::safeTransferFrom_1)
					}
					safeTransferFrom_1
				},
				{
					fn tokenURI(data: &[u8]) -> alloy_sol_types::Result<MockERC721Calls> {
						<tokenURICall as alloy_sol_types::SolCall>::abi_decode_raw(data).map(MockERC721Calls::tokenURI)
					}
					tokenURI
				},
				{
					fn isApprovedForAll(data: &[u8]) -> alloy_sol_types::Result<MockERC721Calls> {
						<isApprovedForAllCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
							.map(MockERC721Calls::isApprovedForAll)
					}
					isApprovedForAll
				},
			];
			let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
				return Err(alloy_sol_types::Error::unknown_selector(
					<Self as alloy_sol_types::SolInterface>::NAME,
					selector,
				));
			};
			DECODE_SHIMS[idx](data)
		}
		#[inline]
		#[allow(non_snake_case)]
		fn abi_decode_raw_validate(selector: [u8; 4], data: &[u8]) -> alloy_sol_types::Result<Self> {
			static DECODE_VALIDATE_SHIMS: &[fn(&[u8]) -> alloy_sol_types::Result<MockERC721Calls>] = &[
				{
					fn supportsInterface(data: &[u8]) -> alloy_sol_types::Result<MockERC721Calls> {
						<supportsInterfaceCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(data)
							.map(MockERC721Calls::supportsInterface)
					}
					supportsInterface
				},
				{
					fn name(data: &[u8]) -> alloy_sol_types::Result<MockERC721Calls> {
						<nameCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(data).map(MockERC721Calls::name)
					}
					name
				},
				{
					fn getApproved(data: &[u8]) -> alloy_sol_types::Result<MockERC721Calls> {
						<getApprovedCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(data)
							.map(MockERC721Calls::getApproved)
					}
					getApproved
				},
				{
					fn approve(data: &[u8]) -> alloy_sol_types::Result<MockERC721Calls> {
						<approveCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(data)
							.map(MockERC721Calls::approve)
					}
					approve
				},
				{
					fn transferFrom(data: &[u8]) -> alloy_sol_types::Result<MockERC721Calls> {
						<transferFromCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(data)
							.map(MockERC721Calls::transferFrom)
					}
					transferFrom
				},
				{
					fn safeTransferFrom_0(data: &[u8]) -> alloy_sol_types::Result<MockERC721Calls> {
						<safeTransferFrom_0Call as alloy_sol_types::SolCall>::abi_decode_raw_validate(data)
							.map(MockERC721Calls::safeTransferFrom_0)
					}
					safeTransferFrom_0
				},
				{
					fn initialize(data: &[u8]) -> alloy_sol_types::Result<MockERC721Calls> {
						<initializeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(data)
							.map(MockERC721Calls::initialize)
					}
					initialize
				},
				{
					fn ownerOf(data: &[u8]) -> alloy_sol_types::Result<MockERC721Calls> {
						<ownerOfCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(data)
							.map(MockERC721Calls::ownerOf)
					}
					ownerOf
				},
				{
					fn balanceOf(data: &[u8]) -> alloy_sol_types::Result<MockERC721Calls> {
						<balanceOfCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(data)
							.map(MockERC721Calls::balanceOf)
					}
					balanceOf
				},
				{
					fn symbol(data: &[u8]) -> alloy_sol_types::Result<MockERC721Calls> {
						<symbolCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(data)
							.map(MockERC721Calls::symbol)
					}
					symbol
				},
				{
					fn setApprovalForAll(data: &[u8]) -> alloy_sol_types::Result<MockERC721Calls> {
						<setApprovalForAllCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(data)
							.map(MockERC721Calls::setApprovalForAll)
					}
					setApprovalForAll
				},
				{
					fn safeTransferFrom_1(data: &[u8]) -> alloy_sol_types::Result<MockERC721Calls> {
						<safeTransferFrom_1Call as alloy_sol_types::SolCall>::abi_decode_raw_validate(data)
							.map(MockERC721Calls::safeTransferFrom_1)
					}
					safeTransferFrom_1
				},
				{
					fn tokenURI(data: &[u8]) -> alloy_sol_types::Result<MockERC721Calls> {
						<tokenURICall as alloy_sol_types::SolCall>::abi_decode_raw_validate(data)
							.map(MockERC721Calls::tokenURI)
					}
					tokenURI
				},
				{
					fn isApprovedForAll(data: &[u8]) -> alloy_sol_types::Result<MockERC721Calls> {
						<isApprovedForAllCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(data)
							.map(MockERC721Calls::isApprovedForAll)
					}
					isApprovedForAll
				},
			];
			let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
				return Err(alloy_sol_types::Error::unknown_selector(
					<Self as alloy_sol_types::SolInterface>::NAME,
					selector,
				));
			};
			DECODE_VALIDATE_SHIMS[idx](data)
		}
		#[inline]
		fn abi_encoded_size(&self) -> usize {
			match self {
				Self::approve(inner) => <approveCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
				Self::balanceOf(inner) => <balanceOfCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
				Self::getApproved(inner) => <getApprovedCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
				Self::initialize(inner) => <initializeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
				Self::isApprovedForAll(inner) => {
					<isApprovedForAllCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
				}
				Self::name(inner) => <nameCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
				Self::ownerOf(inner) => <ownerOfCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
				Self::safeTransferFrom_0(inner) => {
					<safeTransferFrom_0Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
				}
				Self::safeTransferFrom_1(inner) => {
					<safeTransferFrom_1Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
				}
				Self::setApprovalForAll(inner) => {
					<setApprovalForAllCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
				}
				Self::supportsInterface(inner) => {
					<supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
				}
				Self::symbol(inner) => <symbolCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
				Self::tokenURI(inner) => <tokenURICall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
				Self::transferFrom(inner) => <transferFromCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
			}
		}
		#[inline]
		fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
			match self {
				Self::approve(inner) => <approveCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
				Self::balanceOf(inner) => <balanceOfCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
				Self::getApproved(inner) => <getApprovedCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
				Self::initialize(inner) => <initializeCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
				Self::isApprovedForAll(inner) => {
					<isApprovedForAllCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
				}
				Self::name(inner) => <nameCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
				Self::ownerOf(inner) => <ownerOfCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
				Self::safeTransferFrom_0(inner) => {
					<safeTransferFrom_0Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
				}
				Self::safeTransferFrom_1(inner) => {
					<safeTransferFrom_1Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
				}
				Self::setApprovalForAll(inner) => {
					<setApprovalForAllCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
				}
				Self::supportsInterface(inner) => {
					<supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
				}
				Self::symbol(inner) => <symbolCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
				Self::tokenURI(inner) => <tokenURICall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
				Self::transferFrom(inner) => <transferFromCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
			}
		}
	}
	///Container for all the [`MockERC721`](self) events.
	#[derive(Clone, serde::Serialize, serde::Deserialize, Debug, PartialEq, Eq, Hash)]
	pub enum MockERC721Events {
		#[allow(missing_docs)]
		Approval(Approval),
		#[allow(missing_docs)]
		ApprovalForAll(ApprovalForAll),
		#[allow(missing_docs)]
		Transfer(Transfer),
	}
	impl MockERC721Events {
		/// All the selectors of this enum.
		///
		/// Note that the selectors might not be in the same order as the variants.
		/// No guarantees are made about the order of the selectors.
		///
		/// Prefer using `SolInterface` methods instead.
		pub const SELECTORS: &'static [[u8; 32usize]] = &[
			[
				23u8, 48u8, 126u8, 171u8, 57u8, 171u8, 97u8, 7u8, 232u8, 137u8, 152u8, 69u8, 173u8, 61u8, 89u8, 189u8,
				150u8, 83u8, 242u8, 0u8, 242u8, 32u8, 146u8, 4u8, 137u8, 202u8, 43u8, 89u8, 55u8, 105u8, 108u8, 49u8,
			],
			[
				140u8, 91u8, 225u8, 229u8, 235u8, 236u8, 125u8, 91u8, 209u8, 79u8, 113u8, 66u8, 125u8, 30u8, 132u8,
				243u8, 221u8, 3u8, 20u8, 192u8, 247u8, 178u8, 41u8, 30u8, 91u8, 32u8, 10u8, 200u8, 199u8, 195u8, 185u8,
				37u8,
			],
			[
				221u8, 242u8, 82u8, 173u8, 27u8, 226u8, 200u8, 155u8, 105u8, 194u8, 176u8, 104u8, 252u8, 55u8, 141u8,
				170u8, 149u8, 43u8, 167u8, 241u8, 99u8, 196u8, 161u8, 22u8, 40u8, 245u8, 90u8, 77u8, 245u8, 35u8,
				179u8, 239u8,
			],
		];
		/// The names of the variants in the same order as `SELECTORS`.
		pub const VARIANT_NAMES: &'static [&'static str] =
			&[::core::stringify!(ApprovalForAll), ::core::stringify!(Approval), ::core::stringify!(Transfer)];
		/// The signatures in the same order as `SELECTORS`.
		pub const SIGNATURES: &'static [&'static str] = &[
			<ApprovalForAll as alloy_sol_types::SolEvent>::SIGNATURE,
			<Approval as alloy_sol_types::SolEvent>::SIGNATURE,
			<Transfer as alloy_sol_types::SolEvent>::SIGNATURE,
		];
		/// Returns the signature for the given selector, if known.
		#[inline]
		pub fn signature_by_selector(selector: [u8; 32usize]) -> ::core::option::Option<&'static str> {
			match Self::SELECTORS.binary_search(&selector) {
				::core::result::Result::Ok(idx) => ::core::option::Option::Some(Self::SIGNATURES[idx]),
				::core::result::Result::Err(_) => ::core::option::Option::None,
			}
		}
		/// Returns the enum variant name for the given selector, if known.
		#[inline]
		pub fn name_by_selector(selector: [u8; 32usize]) -> ::core::option::Option<&'static str> {
			let sig = Self::signature_by_selector(selector)?;
			sig.split_once('(').map(|(name, _)| name)
		}
	}
	#[automatically_derived]
	impl alloy_sol_types::SolEventInterface for MockERC721Events {
		const NAME: &'static str = "MockERC721Events";
		const COUNT: usize = 3usize;
		fn decode_raw_log(topics: &[alloy_sol_types::Word], data: &[u8]) -> alloy_sol_types::Result<Self> {
			match topics.first().copied() {
				Some(<Approval as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
					<Approval as alloy_sol_types::SolEvent>::decode_raw_log(topics, data).map(Self::Approval)
				}
				Some(<ApprovalForAll as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
					<ApprovalForAll as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
						.map(Self::ApprovalForAll)
				}
				Some(<Transfer as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
					<Transfer as alloy_sol_types::SolEvent>::decode_raw_log(topics, data).map(Self::Transfer)
				}
				_ => alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
					name: <Self as alloy_sol_types::SolEventInterface>::NAME,
					log: alloy_sol_types::private::Box::new(alloy_sol_types::private::LogData::new_unchecked(
						topics.to_vec(),
						data.to_vec().into(),
					)),
				}),
			}
		}
	}
	#[automatically_derived]
	impl alloy_sol_types::private::IntoLogData for MockERC721Events {
		fn to_log_data(&self) -> alloy_sol_types::private::LogData {
			match self {
				Self::Approval(inner) => alloy_sol_types::private::IntoLogData::to_log_data(inner),
				Self::ApprovalForAll(inner) => alloy_sol_types::private::IntoLogData::to_log_data(inner),
				Self::Transfer(inner) => alloy_sol_types::private::IntoLogData::to_log_data(inner),
			}
		}
		fn into_log_data(self) -> alloy_sol_types::private::LogData {
			match self {
				Self::Approval(inner) => alloy_sol_types::private::IntoLogData::into_log_data(inner),
				Self::ApprovalForAll(inner) => alloy_sol_types::private::IntoLogData::into_log_data(inner),
				Self::Transfer(inner) => alloy_sol_types::private::IntoLogData::into_log_data(inner),
			}
		}
	}
	use alloy::contract as alloy_contract;
	/**Creates a new wrapper around an on-chain [`MockERC721`](self) contract instance.

	See the [wrapper's documentation](`MockERC721Instance`) for more details.*/
	#[inline]
	pub const fn new<P: alloy_contract::private::Provider<N>, N: alloy_contract::private::Network>(
		address: alloy_sol_types::private::Address,
		__provider: P,
	) -> MockERC721Instance<P, N> {
		MockERC721Instance::<P, N>::new(address, __provider)
	}
	/**Deploys this contract using the given `provider` and constructor arguments, if any.

	Returns a new instance of the contract, if the deployment was successful.

	For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
	#[inline]
	pub fn deploy<P: alloy_contract::private::Provider<N>, N: alloy_contract::private::Network>(
		__provider: P,
	) -> impl ::core::future::Future<Output = alloy_contract::Result<MockERC721Instance<P, N>>> {
		MockERC721Instance::<P, N>::deploy(__provider)
	}
	/**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
	and constructor arguments, if any.

	This is a simple wrapper around creating a `RawCallBuilder` with the data set to
	the bytecode concatenated with the constructor's ABI-encoded arguments.*/
	#[inline]
	pub fn deploy_builder<P: alloy_contract::private::Provider<N>, N: alloy_contract::private::Network>(
		__provider: P,
	) -> alloy_contract::RawCallBuilder<P, N> {
		MockERC721Instance::<P, N>::deploy_builder(__provider)
	}
	/**A [`MockERC721`](self) instance.

	Contains type-safe methods for interacting with an on-chain instance of the
	[`MockERC721`](self) contract located at a given `address`, using a given
	provider `P`.

	If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
	documentation on how to provide it), the `deploy` and `deploy_builder` methods can
	be used to deploy a new instance of the contract.

	See the [module-level documentation](self) for all the available methods.*/
	#[derive(Clone)]
	pub struct MockERC721Instance<P, N = alloy_contract::private::Ethereum> {
		address: alloy_sol_types::private::Address,
		provider: P,
		_network: ::core::marker::PhantomData<N>,
	}
	#[automatically_derived]
	impl<P, N> ::core::fmt::Debug for MockERC721Instance<P, N> {
		#[inline]
		fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
			f.debug_tuple("MockERC721Instance").field(&self.address).finish()
		}
	}
	/// Instantiation and getters/setters.
	impl<P: alloy_contract::private::Provider<N>, N: alloy_contract::private::Network> MockERC721Instance<P, N> {
		/**Creates a new wrapper around an on-chain [`MockERC721`](self) contract instance.

		See the [wrapper's documentation](`MockERC721Instance`) for more details.*/
		#[inline]
		pub const fn new(address: alloy_sol_types::private::Address, __provider: P) -> Self {
			Self { address, provider: __provider, _network: ::core::marker::PhantomData }
		}
		/**Deploys this contract using the given `provider` and constructor arguments, if any.

		Returns a new instance of the contract, if the deployment was successful.

		For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
		#[inline]
		pub async fn deploy(__provider: P) -> alloy_contract::Result<MockERC721Instance<P, N>> {
			let call_builder = Self::deploy_builder(__provider);
			let contract_address = call_builder.deploy().await?;
			Ok(Self::new(contract_address, call_builder.provider))
		}
		/**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
		and constructor arguments, if any.

		This is a simple wrapper around creating a `RawCallBuilder` with the data set to
		the bytecode concatenated with the constructor's ABI-encoded arguments.*/
		#[inline]
		pub fn deploy_builder(__provider: P) -> alloy_contract::RawCallBuilder<P, N> {
			alloy_contract::RawCallBuilder::new_raw_deploy(__provider, ::core::clone::Clone::clone(&BYTECODE))
		}
		/// Returns a reference to the address.
		#[inline]
		pub const fn address(&self) -> &alloy_sol_types::private::Address {
			&self.address
		}
		/// Sets the address.
		#[inline]
		pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
			self.address = address;
		}
		/// Sets the address and returns `self`.
		pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
			self.set_address(address);
			self
		}
		/// Returns a reference to the provider.
		#[inline]
		pub const fn provider(&self) -> &P {
			&self.provider
		}
	}
	impl<P: ::core::clone::Clone, N> MockERC721Instance<&P, N> {
		/// Clones the provider and returns a new instance with the cloned provider.
		#[inline]
		pub fn with_cloned_provider(self) -> MockERC721Instance<P, N> {
			MockERC721Instance {
				address: self.address,
				provider: ::core::clone::Clone::clone(&self.provider),
				_network: ::core::marker::PhantomData,
			}
		}
	}
	/// Function calls.
	impl<P: alloy_contract::private::Provider<N>, N: alloy_contract::private::Network> MockERC721Instance<P, N> {
		/// Creates a new call builder using this contract instance's provider and address.
		///
		/// Note that the call can be any function call, not just those defined in this
		/// contract. Prefer using the other methods for building type-safe contract calls.
		pub fn call_builder<C: alloy_sol_types::SolCall>(&self, call: &C) -> alloy_contract::SolCallBuilder<&P, C, N> {
			alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
		}
		///Creates a new call builder for the [`approve`] function.
		pub fn approve(
			&self,
			spender: alloy::sol_types::private::Address,
			id: alloy::sol_types::private::primitives::aliases::U256,
		) -> alloy_contract::SolCallBuilder<&P, approveCall, N> {
			self.call_builder(&approveCall { spender, id })
		}
		///Creates a new call builder for the [`balanceOf`] function.
		pub fn balanceOf(
			&self,
			owner: alloy::sol_types::private::Address,
		) -> alloy_contract::SolCallBuilder<&P, balanceOfCall, N> {
			self.call_builder(&balanceOfCall { owner })
		}
		///Creates a new call builder for the [`getApproved`] function.
		pub fn getApproved(
			&self,
			id: alloy::sol_types::private::primitives::aliases::U256,
		) -> alloy_contract::SolCallBuilder<&P, getApprovedCall, N> {
			self.call_builder(&getApprovedCall { id })
		}
		///Creates a new call builder for the [`initialize`] function.
		pub fn initialize(
			&self,
			name_: alloy::sol_types::private::String,
			symbol_: alloy::sol_types::private::String,
		) -> alloy_contract::SolCallBuilder<&P, initializeCall, N> {
			self.call_builder(&initializeCall { name_, symbol_ })
		}
		///Creates a new call builder for the [`isApprovedForAll`] function.
		pub fn isApprovedForAll(
			&self,
			owner: alloy::sol_types::private::Address,
			operator: alloy::sol_types::private::Address,
		) -> alloy_contract::SolCallBuilder<&P, isApprovedForAllCall, N> {
			self.call_builder(&isApprovedForAllCall { owner, operator })
		}
		///Creates a new call builder for the [`name`] function.
		pub fn name(&self) -> alloy_contract::SolCallBuilder<&P, nameCall, N> {
			self.call_builder(&nameCall)
		}
		///Creates a new call builder for the [`ownerOf`] function.
		pub fn ownerOf(
			&self,
			id: alloy::sol_types::private::primitives::aliases::U256,
		) -> alloy_contract::SolCallBuilder<&P, ownerOfCall, N> {
			self.call_builder(&ownerOfCall { id })
		}
		///Creates a new call builder for the [`safeTransferFrom_0`] function.
		pub fn safeTransferFrom_0(
			&self,
			from: alloy::sol_types::private::Address,
			to: alloy::sol_types::private::Address,
			id: alloy::sol_types::private::primitives::aliases::U256,
		) -> alloy_contract::SolCallBuilder<&P, safeTransferFrom_0Call, N> {
			self.call_builder(&safeTransferFrom_0Call { from, to, id })
		}
		///Creates a new call builder for the [`safeTransferFrom_1`] function.
		pub fn safeTransferFrom_1(
			&self,
			from: alloy::sol_types::private::Address,
			to: alloy::sol_types::private::Address,
			id: alloy::sol_types::private::primitives::aliases::U256,
			data: alloy::sol_types::private::Bytes,
		) -> alloy_contract::SolCallBuilder<&P, safeTransferFrom_1Call, N> {
			self.call_builder(&safeTransferFrom_1Call { from, to, id, data })
		}
		///Creates a new call builder for the [`setApprovalForAll`] function.
		pub fn setApprovalForAll(
			&self,
			operator: alloy::sol_types::private::Address,
			approved: bool,
		) -> alloy_contract::SolCallBuilder<&P, setApprovalForAllCall, N> {
			self.call_builder(&setApprovalForAllCall { operator, approved })
		}
		///Creates a new call builder for the [`supportsInterface`] function.
		pub fn supportsInterface(
			&self,
			interfaceId: alloy::sol_types::private::FixedBytes<4>,
		) -> alloy_contract::SolCallBuilder<&P, supportsInterfaceCall, N> {
			self.call_builder(&supportsInterfaceCall { interfaceId })
		}
		///Creates a new call builder for the [`symbol`] function.
		pub fn symbol(&self) -> alloy_contract::SolCallBuilder<&P, symbolCall, N> {
			self.call_builder(&symbolCall)
		}
		///Creates a new call builder for the [`tokenURI`] function.
		pub fn tokenURI(
			&self,
			id: alloy::sol_types::private::primitives::aliases::U256,
		) -> alloy_contract::SolCallBuilder<&P, tokenURICall, N> {
			self.call_builder(&tokenURICall { id })
		}
		///Creates a new call builder for the [`transferFrom`] function.
		pub fn transferFrom(
			&self,
			from: alloy::sol_types::private::Address,
			to: alloy::sol_types::private::Address,
			id: alloy::sol_types::private::primitives::aliases::U256,
		) -> alloy_contract::SolCallBuilder<&P, transferFromCall, N> {
			self.call_builder(&transferFromCall { from, to, id })
		}
	}
	/// Event filters.
	impl<P: alloy_contract::private::Provider<N>, N: alloy_contract::private::Network> MockERC721Instance<P, N> {
		/// Creates a new event filter using this contract instance's provider and address.
		///
		/// Note that the type can be any event, not just those defined in this contract.
		/// Prefer using the other methods for building type-safe event filters.
		pub fn event_filter<E: alloy_sol_types::SolEvent>(&self) -> alloy_contract::Event<&P, E, N> {
			alloy_contract::Event::new_sol(&self.provider, &self.address)
		}
		///Creates a new event filter for the [`Approval`] event.
		pub fn Approval_filter(&self) -> alloy_contract::Event<&P, Approval, N> {
			self.event_filter::<Approval>()
		}
		///Creates a new event filter for the [`ApprovalForAll`] event.
		pub fn ApprovalForAll_filter(&self) -> alloy_contract::Event<&P, ApprovalForAll, N> {
			self.event_filter::<ApprovalForAll>()
		}
		///Creates a new event filter for the [`Transfer`] event.
		pub fn Transfer_filter(&self) -> alloy_contract::Event<&P, Transfer, N> {
			self.event_filter::<Transfer>()
		}
	}
}
