/**

Generated by the following Solidity interface...
```solidity
interface MockERC20 {
	event Approval(address indexed owner, address indexed spender, uint256 value);
	event Transfer(address indexed from, address indexed to, uint256 value);

	function DOMAIN_SEPARATOR() external view returns (bytes32);
	function allowance(address owner, address spender) external view returns (uint256);
	function approve(address spender, uint256 amount) external returns (bool);
	function balanceOf(address owner) external view returns (uint256);
	function decimals() external view returns (uint8);
	function initialize(string memory name_, string memory symbol_, uint8 decimals_) external;
	function name() external view returns (string memory);
	function nonces(address) external view returns (uint256);
	function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;
	function symbol() external view returns (string memory);
	function totalSupply() external view returns (uint256);
	function transfer(address to, uint256 amount) external returns (bool);
	function transferFrom(address from, address to, uint256 amount) external returns (bool);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
	"type": "function",
	"name": "DOMAIN_SEPARATOR",
	"inputs": [],
	"outputs": [
	  {
		"name": "",
		"type": "bytes32",
		"internalType": "bytes32"
	  }
	],
	"stateMutability": "view"
  },
  {
	"type": "function",
	"name": "allowance",
	"inputs": [
	  {
		"name": "owner",
		"type": "address",
		"internalType": "address"
	  },
	  {
		"name": "spender",
		"type": "address",
		"internalType": "address"
	  }
	],
	"outputs": [
	  {
		"name": "",
		"type": "uint256",
		"internalType": "uint256"
	  }
	],
	"stateMutability": "view"
  },
  {
	"type": "function",
	"name": "approve",
	"inputs": [
	  {
		"name": "spender",
		"type": "address",
		"internalType": "address"
	  },
	  {
		"name": "amount",
		"type": "uint256",
		"internalType": "uint256"
	  }
	],
	"outputs": [
	  {
		"name": "",
		"type": "bool",
		"internalType": "bool"
	  }
	],
	"stateMutability": "nonpayable"
  },
  {
	"type": "function",
	"name": "balanceOf",
	"inputs": [
	  {
		"name": "owner",
		"type": "address",
		"internalType": "address"
	  }
	],
	"outputs": [
	  {
		"name": "",
		"type": "uint256",
		"internalType": "uint256"
	  }
	],
	"stateMutability": "view"
  },
  {
	"type": "function",
	"name": "decimals",
	"inputs": [],
	"outputs": [
	  {
		"name": "",
		"type": "uint8",
		"internalType": "uint8"
	  }
	],
	"stateMutability": "view"
  },
  {
	"type": "function",
	"name": "initialize",
	"inputs": [
	  {
		"name": "name_",
		"type": "string",
		"internalType": "string"
	  },
	  {
		"name": "symbol_",
		"type": "string",
		"internalType": "string"
	  },
	  {
		"name": "decimals_",
		"type": "uint8",
		"internalType": "uint8"
	  }
	],
	"outputs": [],
	"stateMutability": "nonpayable"
  },
  {
	"type": "function",
	"name": "name",
	"inputs": [],
	"outputs": [
	  {
		"name": "",
		"type": "string",
		"internalType": "string"
	  }
	],
	"stateMutability": "view"
  },
  {
	"type": "function",
	"name": "nonces",
	"inputs": [
	  {
		"name": "",
		"type": "address",
		"internalType": "address"
	  }
	],
	"outputs": [
	  {
		"name": "",
		"type": "uint256",
		"internalType": "uint256"
	  }
	],
	"stateMutability": "view"
  },
  {
	"type": "function",
	"name": "permit",
	"inputs": [
	  {
		"name": "owner",
		"type": "address",
		"internalType": "address"
	  },
	  {
		"name": "spender",
		"type": "address",
		"internalType": "address"
	  },
	  {
		"name": "value",
		"type": "uint256",
		"internalType": "uint256"
	  },
	  {
		"name": "deadline",
		"type": "uint256",
		"internalType": "uint256"
	  },
	  {
		"name": "v",
		"type": "uint8",
		"internalType": "uint8"
	  },
	  {
		"name": "r",
		"type": "bytes32",
		"internalType": "bytes32"
	  },
	  {
		"name": "s",
		"type": "bytes32",
		"internalType": "bytes32"
	  }
	],
	"outputs": [],
	"stateMutability": "nonpayable"
  },
  {
	"type": "function",
	"name": "symbol",
	"inputs": [],
	"outputs": [
	  {
		"name": "",
		"type": "string",
		"internalType": "string"
	  }
	],
	"stateMutability": "view"
  },
  {
	"type": "function",
	"name": "totalSupply",
	"inputs": [],
	"outputs": [
	  {
		"name": "",
		"type": "uint256",
		"internalType": "uint256"
	  }
	],
	"stateMutability": "view"
  },
  {
	"type": "function",
	"name": "transfer",
	"inputs": [
	  {
		"name": "to",
		"type": "address",
		"internalType": "address"
	  },
	  {
		"name": "amount",
		"type": "uint256",
		"internalType": "uint256"
	  }
	],
	"outputs": [
	  {
		"name": "",
		"type": "bool",
		"internalType": "bool"
	  }
	],
	"stateMutability": "nonpayable"
  },
  {
	"type": "function",
	"name": "transferFrom",
	"inputs": [
	  {
		"name": "from",
		"type": "address",
		"internalType": "address"
	  },
	  {
		"name": "to",
		"type": "address",
		"internalType": "address"
	  },
	  {
		"name": "amount",
		"type": "uint256",
		"internalType": "uint256"
	  }
	],
	"outputs": [
	  {
		"name": "",
		"type": "bool",
		"internalType": "bool"
	  }
	],
	"stateMutability": "nonpayable"
  },
  {
	"type": "event",
	"name": "Approval",
	"inputs": [
	  {
		"name": "owner",
		"type": "address",
		"indexed": true,
		"internalType": "address"
	  },
	  {
		"name": "spender",
		"type": "address",
		"indexed": true,
		"internalType": "address"
	  },
	  {
		"name": "value",
		"type": "uint256",
		"indexed": false,
		"internalType": "uint256"
	  }
	],
	"anonymous": false
  },
  {
	"type": "event",
	"name": "Transfer",
	"inputs": [
	  {
		"name": "from",
		"type": "address",
		"indexed": true,
		"internalType": "address"
	  },
	  {
		"name": "to",
		"type": "address",
		"indexed": true,
		"internalType": "address"
	  },
	  {
		"name": "value",
		"type": "uint256",
		"indexed": false,
		"internalType": "uint256"
	  }
	],
	"anonymous": false
  }
]
```*/
#[allow(
	non_camel_case_types,
	non_snake_case,
	clippy::pub_underscore_fields,
	clippy::style,
	clippy::empty_structs_with_brackets
)]
pub mod MockERC20 {
	use super::*;
	use alloy::sol_types as alloy_sol_types;
	/// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x6080604052348015600e575f80fd5b50610e138061001c5f395ff3fe608060405234801561000f575f80fd5b50600436106100cb575f3560e01c80633644e5151161008857806395d89b411161006357806395d89b41146101ae578063a9059cbb146101b6578063d505accf146101c9578063dd62ed3e146101dc575f80fd5b80633644e5151461015f57806370a08231146101675780637ecebe001461018f575f80fd5b806306fdde03146100cf578063095ea7b3146100ed5780631624f6c61461011057806318160ddd1461012557806323b872dd14610137578063313ce5671461014a575b5f80fd5b6100d7610214565b6040516100e49190610959565b60405180910390f35b6101006100fb3660046109a9565b6102a3565b60405190151581526020016100e4565b61012361011e366004610a7e565b61030f565b005b6003545b6040519081526020016100e4565b610100610145366004610aed565b6103ad565b60025460405160ff90911681526020016100e4565b6101296104bc565b610129610175366004610b26565b6001600160a01b03165f9081526004602052604090205490565b61012961019d366004610b26565b60086020525f908152604090205481565b6100d76104e1565b6101006101c43660046109a9565b6104f0565b6101236101d7366004610b3f565b610584565b6101296101ea366004610ba4565b6001600160a01b039182165f90815260056020908152604080832093909416825291909152205490565b60605f805461022290610bd5565b80601f016020809104026020016040519081016040528092919081815260200182805461024e90610bd5565b80156102995780601f1061027057610100808354040283529160200191610299565b820191905f5260205f20905b81548152906001019060200180831161027c57829003601f168201915b5050505050905090565b335f8181526005602090815260408083206001600160a01b038716808552925280832085905551919290917f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925906102fd9086815260200190565b60405180910390a35060015b92915050565b60095460ff161561035d5760405162461bcd60e51b81526020600482015260136024820152721053149150511657d253925512505312569151606a1b60448201526064015b60405180910390fd5b5f6103688482610c59565b5060016103758382610c59565b506002805460ff191660ff831617905561038d6107dc565b6006556103986107f4565b60075550506009805460ff1916600117905550565b6001600160a01b0383165f9081526005602090815260408083203384529091528120545f198114610406576103e28184610895565b6001600160a01b0386165f9081526005602090815260408083203384529091529020555b6001600160a01b0385165f908152600460205260409020546104289084610895565b6001600160a01b038087165f90815260046020526040808220939093559086168152205461045690846108f7565b6001600160a01b038086165f8181526004602052604090819020939093559151908716907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef906104a99087815260200190565b60405180910390a3506001949350505050565b5f6006546104c86107dc565b146104da576104d56107f4565b905090565b5060075490565b60606001805461022290610bd5565b335f908152600460205260408120546105099083610895565b335f90815260046020526040808220929092556001600160a01b0385168152205461053490836108f7565b6001600160a01b0384165f818152600460205260409081902092909255905133907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef906102fd9086815260200190565b428410156105d45760405162461bcd60e51b815260206004820152601760248201527f5045524d49545f444541444c494e455f455850495245440000000000000000006044820152606401610354565b5f60016105df6104bc565b6001600160a01b038a165f90815260086020526040812080547f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9928d928d928d9290919061062c83610d2d565b909155506040805160208101969096526001600160a01b0394851690860152929091166060840152608083015260a082015260c0810188905260e001604051602081830303815290604052805190602001206040516020016106a592919061190160f01b81526002810192909252602282015260420190565b60408051601f1981840301815282825280516020918201205f84529083018083525260ff871690820152606081018590526080810184905260a0016020604051602081039080840390855afa158015610700573d5f803e3d5ffd5b5050604051601f1901519150506001600160a01b038116158015906107365750876001600160a01b0316816001600160a01b0316145b6107735760405162461bcd60e51b815260206004820152600e60248201526d24a72b20a624a22fa9a4a3a722a960911b6044820152606401610354565b6001600160a01b038181165f9081526005602090815260408083208b8516808552908352928190208a90555189815291928b16917f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925910160405180910390a35050505050505050565b5f610955806107ed63ffffffff8216565b9250505090565b5f7f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f5f6040516108249190610d45565b60405180910390207fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc66108556107dc565b604080516020810195909552840192909252606083015260808201523060a082015260c00160405160208183030381529060405280519060200120905090565b5f818310156108e65760405162461bcd60e51b815260206004820152601c60248201527f45524332303a207375627472616374696f6e20756e646572666c6f77000000006044820152606401610354565b6108f08284610db7565b9392505050565b5f806109038385610dca565b9050838110156108f05760405162461bcd60e51b815260206004820152601860248201527f45524332303a206164646974696f6e206f766572666c6f7700000000000000006044820152606401610354565b4690565b602081525f82518060208401528060208501604085015e5f604082850101526040601f19601f83011684010191505092915050565b80356001600160a01b03811681146109a4575f80fd5b919050565b5f80604083850312156109ba575f80fd5b6109c38361098e565b946020939093013593505050565b634e487b7160e01b5f52604160045260245ffd5b5f82601f8301126109f4575f80fd5b813567ffffffffffffffff80821115610a0f57610a0f6109d1565b604051601f8301601f19908116603f01168101908282118183101715610a3757610a376109d1565b81604052838152866020858801011115610a4f575f80fd5b836020870160208301375f602085830101528094505050505092915050565b803560ff811681146109a4575f80fd5b5f805f60608486031215610a90575f80fd5b833567ffffffffffffffff80821115610aa7575f80fd5b610ab3878388016109e5565b94506020860135915080821115610ac8575f80fd5b50610ad5868287016109e5565b925050610ae460408501610a6e565b90509250925092565b5f805f60608486031215610aff575f80fd5b610b088461098e565b9250610b166020850161098e565b9150604084013590509250925092565b5f60208284031215610b36575f80fd5b6108f08261098e565b5f805f805f805f60e0888a031215610b55575f80fd5b610b5e8861098e565b9650610b6c6020890161098e565b95506040880135945060608801359350610b8860808901610a6e565b925060a0880135915060c0880135905092959891949750929550565b5f8060408385031215610bb5575f80fd5b610bbe8361098e565b9150610bcc6020840161098e565b90509250929050565b600181811c90821680610be957607f821691505b602082108103610c0757634e487b7160e01b5f52602260045260245ffd5b50919050565b601f821115610c5457805f5260205f20601f840160051c81016020851015610c325750805b601f840160051c820191505b81811015610c51575f8155600101610c3e565b50505b505050565b815167ffffffffffffffff811115610c7357610c736109d1565b610c8781610c818454610bd5565b84610c0d565b602080601f831160018114610cba575f8415610ca35750858301515b5f19600386901b1c1916600185901b178555610d11565b5f85815260208120601f198616915b82811015610ce857888601518255948401946001909101908401610cc9565b5085821015610d0557878501515f19600388901b60f8161c191681555b505060018460011b0185555b505050505050565b634e487b7160e01b5f52601160045260245ffd5b5f60018201610d3e57610d3e610d19565b5060010190565b5f808354610d5281610bd5565b60018281168015610d6a5760018114610d7f57610dab565b60ff1984168752821515830287019450610dab565b875f526020805f205f5b85811015610da25781548a820152908401908201610d89565b50505082870194505b50929695505050505050565b8181038181111561030957610309610d19565b8082018082111561030957610309610d1956fea2646970667358221220dadb91b32a6298680d5ea18d37955b10b6c2867bc14b579fd9e8271e81a3cc9364736f6c63430008190033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15`\x0EW_\x80\xFD[Pa\x0E\x13\x80a\0\x1C_9_\xF3\xFE`\x80`@R4\x80\x15a\0\x0FW_\x80\xFD[P`\x046\x10a\0\xCBW_5`\xE0\x1C\x80c6D\xE5\x15\x11a\0\x88W\x80c\x95\xD8\x9BA\x11a\0cW\x80c\x95\xD8\x9BA\x14a\x01\xAEW\x80c\xA9\x05\x9C\xBB\x14a\x01\xB6W\x80c\xD5\x05\xAC\xCF\x14a\x01\xC9W\x80c\xDDb\xED>\x14a\x01\xDCW_\x80\xFD[\x80c6D\xE5\x15\x14a\x01_W\x80cp\xA0\x821\x14a\x01gW\x80c~\xCE\xBE\0\x14a\x01\x8FW_\x80\xFD[\x80c\x06\xFD\xDE\x03\x14a\0\xCFW\x80c\t^\xA7\xB3\x14a\0\xEDW\x80c\x16$\xF6\xC6\x14a\x01\x10W\x80c\x18\x16\r\xDD\x14a\x01%W\x80c#\xB8r\xDD\x14a\x017W\x80c1<\xE5g\x14a\x01JW[_\x80\xFD[a\0\xD7a\x02\x14V[`@Qa\0\xE4\x91\x90a\tYV[`@Q\x80\x91\x03\x90\xF3[a\x01\0a\0\xFB6`\x04a\t\xA9V[a\x02\xA3V[`@Q\x90\x15\x15\x81R` \x01a\0\xE4V[a\x01#a\x01\x1E6`\x04a\n~V[a\x03\x0FV[\0[`\x03T[`@Q\x90\x81R` \x01a\0\xE4V[a\x01\0a\x01E6`\x04a\n\xEDV[a\x03\xADV[`\x02T`@Q`\xFF\x90\x91\x16\x81R` \x01a\0\xE4V[a\x01)a\x04\xBCV[a\x01)a\x01u6`\x04a\x0B&V[`\x01`\x01`\xA0\x1B\x03\x16_\x90\x81R`\x04` R`@\x90 T\x90V[a\x01)a\x01\x9D6`\x04a\x0B&V[`\x08` R_\x90\x81R`@\x90 T\x81V[a\0\xD7a\x04\xE1V[a\x01\0a\x01\xC46`\x04a\t\xA9V[a\x04\xF0V[a\x01#a\x01\xD76`\x04a\x0B?V[a\x05\x84V[a\x01)a\x01\xEA6`\x04a\x0B\xA4V[`\x01`\x01`\xA0\x1B\x03\x91\x82\x16_\x90\x81R`\x05` \x90\x81R`@\x80\x83 \x93\x90\x94\x16\x82R\x91\x90\x91R T\x90V[``_\x80Ta\x02\"\x90a\x0B\xD5V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x02N\x90a\x0B\xD5V[\x80\x15a\x02\x99W\x80`\x1F\x10a\x02pWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x02\x99V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x02|W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x90P\x90V[3_\x81\x81R`\x05` \x90\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x87\x16\x80\x85R\x92R\x80\x83 \x85\x90UQ\x91\x92\x90\x91\x7F\x8C[\xE1\xE5\xEB\xEC}[\xD1OqB}\x1E\x84\xF3\xDD\x03\x14\xC0\xF7\xB2)\x1E[ \n\xC8\xC7\xC3\xB9%\x90a\x02\xFD\x90\x86\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA3P`\x01[\x92\x91PPV[`\tT`\xFF\x16\x15a\x03]W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x13`$\x82\x01Rr\x10S\x14\x91PQ\x16W\xD2S\x92U\x12PS\x12V\x91Q`j\x1B`D\x82\x01R`d\x01[`@Q\x80\x91\x03\x90\xFD[_a\x03h\x84\x82a\x0CYV[P`\x01a\x03u\x83\x82a\x0CYV[P`\x02\x80T`\xFF\x19\x16`\xFF\x83\x16\x17\x90Ua\x03\x8Da\x07\xDCV[`\x06Ua\x03\x98a\x07\xF4V[`\x07UPP`\t\x80T`\xFF\x19\x16`\x01\x17\x90UPV[`\x01`\x01`\xA0\x1B\x03\x83\x16_\x90\x81R`\x05` \x90\x81R`@\x80\x83 3\x84R\x90\x91R\x81 T_\x19\x81\x14a\x04\x06Wa\x03\xE2\x81\x84a\x08\x95V[`\x01`\x01`\xA0\x1B\x03\x86\x16_\x90\x81R`\x05` \x90\x81R`@\x80\x83 3\x84R\x90\x91R\x90 U[`\x01`\x01`\xA0\x1B\x03\x85\x16_\x90\x81R`\x04` R`@\x90 Ta\x04(\x90\x84a\x08\x95V[`\x01`\x01`\xA0\x1B\x03\x80\x87\x16_\x90\x81R`\x04` R`@\x80\x82 \x93\x90\x93U\x90\x86\x16\x81R Ta\x04V\x90\x84a\x08\xF7V[`\x01`\x01`\xA0\x1B\x03\x80\x86\x16_\x81\x81R`\x04` R`@\x90\x81\x90 \x93\x90\x93U\x91Q\x90\x87\x16\x90\x7F\xDD\xF2R\xAD\x1B\xE2\xC8\x9Bi\xC2\xB0h\xFC7\x8D\xAA\x95+\xA7\xF1c\xC4\xA1\x16(\xF5ZM\xF5#\xB3\xEF\x90a\x04\xA9\x90\x87\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA3P`\x01\x94\x93PPPPV[_`\x06Ta\x04\xC8a\x07\xDCV[\x14a\x04\xDAWa\x04\xD5a\x07\xF4V[\x90P\x90V[P`\x07T\x90V[```\x01\x80Ta\x02\"\x90a\x0B\xD5V[3_\x90\x81R`\x04` R`@\x81 Ta\x05\t\x90\x83a\x08\x95V[3_\x90\x81R`\x04` R`@\x80\x82 \x92\x90\x92U`\x01`\x01`\xA0\x1B\x03\x85\x16\x81R Ta\x054\x90\x83a\x08\xF7V[`\x01`\x01`\xA0\x1B\x03\x84\x16_\x81\x81R`\x04` R`@\x90\x81\x90 \x92\x90\x92U\x90Q3\x90\x7F\xDD\xF2R\xAD\x1B\xE2\xC8\x9Bi\xC2\xB0h\xFC7\x8D\xAA\x95+\xA7\xF1c\xC4\xA1\x16(\xF5ZM\xF5#\xB3\xEF\x90a\x02\xFD\x90\x86\x81R` \x01\x90V[B\x84\x10\x15a\x05\xD4W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x17`$\x82\x01R\x7FPERMIT_DEADLINE_EXPIRED\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x03TV[_`\x01a\x05\xDFa\x04\xBCV[`\x01`\x01`\xA0\x1B\x03\x8A\x16_\x90\x81R`\x08` R`@\x81 \x80T\x7Fnq\xED\xAE\x12\xB1\xB9\x7FM\x1F`7\x0F\xEF\x10\x10_\xA2\xFA\xAE\x01&\x11J\x16\x9Cd\x84]a&\xC9\x92\x8D\x92\x8D\x92\x8D\x92\x90\x91\x90a\x06,\x83a\r-V[\x90\x91UP`@\x80Q` \x81\x01\x96\x90\x96R`\x01`\x01`\xA0\x1B\x03\x94\x85\x16\x90\x86\x01R\x92\x90\x91\x16``\x84\x01R`\x80\x83\x01R`\xA0\x82\x01R`\xC0\x81\x01\x88\x90R`\xE0\x01`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 `@Q` \x01a\x06\xA5\x92\x91\x90a\x19\x01`\xF0\x1B\x81R`\x02\x81\x01\x92\x90\x92R`\"\x82\x01R`B\x01\x90V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x82\x82R\x80Q` \x91\x82\x01 _\x84R\x90\x83\x01\x80\x83RR`\xFF\x87\x16\x90\x82\x01R``\x81\x01\x85\x90R`\x80\x81\x01\x84\x90R`\xA0\x01` `@Q` \x81\x03\x90\x80\x84\x03\x90\x85Z\xFA\x15\x80\x15a\x07\0W=_\x80>=_\xFD[PP`@Q`\x1F\x19\x01Q\x91PP`\x01`\x01`\xA0\x1B\x03\x81\x16\x15\x80\x15\x90a\x076WP\x87`\x01`\x01`\xA0\x1B\x03\x16\x81`\x01`\x01`\xA0\x1B\x03\x16\x14[a\x07sW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0E`$\x82\x01Rm$\xA7+ \xA6$\xA2/\xA9\xA4\xA3\xA7\"\xA9`\x91\x1B`D\x82\x01R`d\x01a\x03TV[`\x01`\x01`\xA0\x1B\x03\x81\x81\x16_\x90\x81R`\x05` \x90\x81R`@\x80\x83 \x8B\x85\x16\x80\x85R\x90\x83R\x92\x81\x90 \x8A\x90UQ\x89\x81R\x91\x92\x8B\x16\x91\x7F\x8C[\xE1\xE5\xEB\xEC}[\xD1OqB}\x1E\x84\xF3\xDD\x03\x14\xC0\xF7\xB2)\x1E[ \n\xC8\xC7\xC3\xB9%\x91\x01`@Q\x80\x91\x03\x90\xA3PPPPPPPPV[_a\tU\x80a\x07\xEDc\xFF\xFF\xFF\xFF\x82\x16V[\x92PPP\x90V[_\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F_`@Qa\x08$\x91\x90a\rEV[`@Q\x80\x91\x03\x90 \x7F\xC8\x9E\xFD\xAAT\xC0\xF2\x0Cz\xDFa(\x82\xDF\tP\xF5\xA9Qc~\x03\x07\xCD\xCBLg/)\x8B\x8B\xC6a\x08Ua\x07\xDCV[`@\x80Q` \x81\x01\x95\x90\x95R\x84\x01\x92\x90\x92R``\x83\x01R`\x80\x82\x01R0`\xA0\x82\x01R`\xC0\x01`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P\x90V[_\x81\x83\x10\x15a\x08\xE6W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7FERC20: subtraction underflow\0\0\0\0`D\x82\x01R`d\x01a\x03TV[a\x08\xF0\x82\x84a\r\xB7V[\x93\x92PPPV[_\x80a\t\x03\x83\x85a\r\xCAV[\x90P\x83\x81\x10\x15a\x08\xF0W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x18`$\x82\x01R\x7FERC20: addition overflow\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x03TV[F\x90V[` \x81R_\x82Q\x80` \x84\x01R\x80` \x85\x01`@\x85\x01^_`@\x82\x85\x01\x01R`@`\x1F\x19`\x1F\x83\x01\x16\x84\x01\x01\x91PP\x92\x91PPV[\x805`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\t\xA4W_\x80\xFD[\x91\x90PV[_\x80`@\x83\x85\x03\x12\x15a\t\xBAW_\x80\xFD[a\t\xC3\x83a\t\x8EV[\x94` \x93\x90\x93\x015\x93PPPV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[_\x82`\x1F\x83\x01\x12a\t\xF4W_\x80\xFD[\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15a\n\x0FWa\n\x0Fa\t\xD1V[`@Q`\x1F\x83\x01`\x1F\x19\x90\x81\x16`?\x01\x16\x81\x01\x90\x82\x82\x11\x81\x83\x10\x17\x15a\n7Wa\n7a\t\xD1V[\x81`@R\x83\x81R\x86` \x85\x88\x01\x01\x11\x15a\nOW_\x80\xFD[\x83` \x87\x01` \x83\x017_` \x85\x83\x01\x01R\x80\x94PPPPP\x92\x91PPV[\x805`\xFF\x81\x16\x81\x14a\t\xA4W_\x80\xFD[_\x80_``\x84\x86\x03\x12\x15a\n\x90W_\x80\xFD[\x835g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15a\n\xA7W_\x80\xFD[a\n\xB3\x87\x83\x88\x01a\t\xE5V[\x94P` \x86\x015\x91P\x80\x82\x11\x15a\n\xC8W_\x80\xFD[Pa\n\xD5\x86\x82\x87\x01a\t\xE5V[\x92PPa\n\xE4`@\x85\x01a\nnV[\x90P\x92P\x92P\x92V[_\x80_``\x84\x86\x03\x12\x15a\n\xFFW_\x80\xFD[a\x0B\x08\x84a\t\x8EV[\x92Pa\x0B\x16` \x85\x01a\t\x8EV[\x91P`@\x84\x015\x90P\x92P\x92P\x92V[_` \x82\x84\x03\x12\x15a\x0B6W_\x80\xFD[a\x08\xF0\x82a\t\x8EV[_\x80_\x80_\x80_`\xE0\x88\x8A\x03\x12\x15a\x0BUW_\x80\xFD[a\x0B^\x88a\t\x8EV[\x96Pa\x0Bl` \x89\x01a\t\x8EV[\x95P`@\x88\x015\x94P``\x88\x015\x93Pa\x0B\x88`\x80\x89\x01a\nnV[\x92P`\xA0\x88\x015\x91P`\xC0\x88\x015\x90P\x92\x95\x98\x91\x94\x97P\x92\x95PV[_\x80`@\x83\x85\x03\x12\x15a\x0B\xB5W_\x80\xFD[a\x0B\xBE\x83a\t\x8EV[\x91Pa\x0B\xCC` \x84\x01a\t\x8EV[\x90P\x92P\x92\x90PV[`\x01\x81\x81\x1C\x90\x82\x16\x80a\x0B\xE9W`\x7F\x82\x16\x91P[` \x82\x10\x81\x03a\x0C\x07WcNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[P\x91\x90PV[`\x1F\x82\x11\x15a\x0CTW\x80_R` _ `\x1F\x84\x01`\x05\x1C\x81\x01` \x85\x10\x15a\x0C2WP\x80[`\x1F\x84\x01`\x05\x1C\x82\x01\x91P[\x81\x81\x10\x15a\x0CQW_\x81U`\x01\x01a\x0C>V[PP[PPPV[\x81Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x0CsWa\x0Csa\t\xD1V[a\x0C\x87\x81a\x0C\x81\x84Ta\x0B\xD5V[\x84a\x0C\rV[` \x80`\x1F\x83\x11`\x01\x81\x14a\x0C\xBAW_\x84\x15a\x0C\xA3WP\x85\x83\x01Q[_\x19`\x03\x86\x90\x1B\x1C\x19\x16`\x01\x85\x90\x1B\x17\x85Ua\r\x11V[_\x85\x81R` \x81 `\x1F\x19\x86\x16\x91[\x82\x81\x10\x15a\x0C\xE8W\x88\x86\x01Q\x82U\x94\x84\x01\x94`\x01\x90\x91\x01\x90\x84\x01a\x0C\xC9V[P\x85\x82\x10\x15a\r\x05W\x87\x85\x01Q_\x19`\x03\x88\x90\x1B`\xF8\x16\x1C\x19\x16\x81U[PP`\x01\x84`\x01\x1B\x01\x85U[PPPPPPV[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[_`\x01\x82\x01a\r>Wa\r>a\r\x19V[P`\x01\x01\x90V[_\x80\x83Ta\rR\x81a\x0B\xD5V[`\x01\x82\x81\x16\x80\x15a\rjW`\x01\x81\x14a\r\x7FWa\r\xABV[`\xFF\x19\x84\x16\x87R\x82\x15\x15\x83\x02\x87\x01\x94Pa\r\xABV[\x87_R` \x80_ _[\x85\x81\x10\x15a\r\xA2W\x81T\x8A\x82\x01R\x90\x84\x01\x90\x82\x01a\r\x89V[PPP\x82\x87\x01\x94P[P\x92\x96\x95PPPPPPV[\x81\x81\x03\x81\x81\x11\x15a\x03\tWa\x03\ta\r\x19V[\x80\x82\x01\x80\x82\x11\x15a\x03\tWa\x03\ta\r\x19V\xFE\xA2dipfsX\"\x12 \xDA\xDB\x91\xB3*b\x98h\r^\xA1\x8D7\x95[\x10\xB6\xC2\x86{\xC1KW\x9F\xD9\xE8'\x1E\x81\xA3\xCC\x93dsolcC\0\x08\x19\x003",
    );
	/// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405234801561000f575f80fd5b50600436106100cb575f3560e01c80633644e5151161008857806395d89b411161006357806395d89b41146101ae578063a9059cbb146101b6578063d505accf146101c9578063dd62ed3e146101dc575f80fd5b80633644e5151461015f57806370a08231146101675780637ecebe001461018f575f80fd5b806306fdde03146100cf578063095ea7b3146100ed5780631624f6c61461011057806318160ddd1461012557806323b872dd14610137578063313ce5671461014a575b5f80fd5b6100d7610214565b6040516100e49190610959565b60405180910390f35b6101006100fb3660046109a9565b6102a3565b60405190151581526020016100e4565b61012361011e366004610a7e565b61030f565b005b6003545b6040519081526020016100e4565b610100610145366004610aed565b6103ad565b60025460405160ff90911681526020016100e4565b6101296104bc565b610129610175366004610b26565b6001600160a01b03165f9081526004602052604090205490565b61012961019d366004610b26565b60086020525f908152604090205481565b6100d76104e1565b6101006101c43660046109a9565b6104f0565b6101236101d7366004610b3f565b610584565b6101296101ea366004610ba4565b6001600160a01b039182165f90815260056020908152604080832093909416825291909152205490565b60605f805461022290610bd5565b80601f016020809104026020016040519081016040528092919081815260200182805461024e90610bd5565b80156102995780601f1061027057610100808354040283529160200191610299565b820191905f5260205f20905b81548152906001019060200180831161027c57829003601f168201915b5050505050905090565b335f8181526005602090815260408083206001600160a01b038716808552925280832085905551919290917f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925906102fd9086815260200190565b60405180910390a35060015b92915050565b60095460ff161561035d5760405162461bcd60e51b81526020600482015260136024820152721053149150511657d253925512505312569151606a1b60448201526064015b60405180910390fd5b5f6103688482610c59565b5060016103758382610c59565b506002805460ff191660ff831617905561038d6107dc565b6006556103986107f4565b60075550506009805460ff1916600117905550565b6001600160a01b0383165f9081526005602090815260408083203384529091528120545f198114610406576103e28184610895565b6001600160a01b0386165f9081526005602090815260408083203384529091529020555b6001600160a01b0385165f908152600460205260409020546104289084610895565b6001600160a01b038087165f90815260046020526040808220939093559086168152205461045690846108f7565b6001600160a01b038086165f8181526004602052604090819020939093559151908716907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef906104a99087815260200190565b60405180910390a3506001949350505050565b5f6006546104c86107dc565b146104da576104d56107f4565b905090565b5060075490565b60606001805461022290610bd5565b335f908152600460205260408120546105099083610895565b335f90815260046020526040808220929092556001600160a01b0385168152205461053490836108f7565b6001600160a01b0384165f818152600460205260409081902092909255905133907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef906102fd9086815260200190565b428410156105d45760405162461bcd60e51b815260206004820152601760248201527f5045524d49545f444541444c494e455f455850495245440000000000000000006044820152606401610354565b5f60016105df6104bc565b6001600160a01b038a165f90815260086020526040812080547f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9928d928d928d9290919061062c83610d2d565b909155506040805160208101969096526001600160a01b0394851690860152929091166060840152608083015260a082015260c0810188905260e001604051602081830303815290604052805190602001206040516020016106a592919061190160f01b81526002810192909252602282015260420190565b60408051601f1981840301815282825280516020918201205f84529083018083525260ff871690820152606081018590526080810184905260a0016020604051602081039080840390855afa158015610700573d5f803e3d5ffd5b5050604051601f1901519150506001600160a01b038116158015906107365750876001600160a01b0316816001600160a01b0316145b6107735760405162461bcd60e51b815260206004820152600e60248201526d24a72b20a624a22fa9a4a3a722a960911b6044820152606401610354565b6001600160a01b038181165f9081526005602090815260408083208b8516808552908352928190208a90555189815291928b16917f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925910160405180910390a35050505050505050565b5f610955806107ed63ffffffff8216565b9250505090565b5f7f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f5f6040516108249190610d45565b60405180910390207fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc66108556107dc565b604080516020810195909552840192909252606083015260808201523060a082015260c00160405160208183030381529060405280519060200120905090565b5f818310156108e65760405162461bcd60e51b815260206004820152601c60248201527f45524332303a207375627472616374696f6e20756e646572666c6f77000000006044820152606401610354565b6108f08284610db7565b9392505050565b5f806109038385610dca565b9050838110156108f05760405162461bcd60e51b815260206004820152601860248201527f45524332303a206164646974696f6e206f766572666c6f7700000000000000006044820152606401610354565b4690565b602081525f82518060208401528060208501604085015e5f604082850101526040601f19601f83011684010191505092915050565b80356001600160a01b03811681146109a4575f80fd5b919050565b5f80604083850312156109ba575f80fd5b6109c38361098e565b946020939093013593505050565b634e487b7160e01b5f52604160045260245ffd5b5f82601f8301126109f4575f80fd5b813567ffffffffffffffff80821115610a0f57610a0f6109d1565b604051601f8301601f19908116603f01168101908282118183101715610a3757610a376109d1565b81604052838152866020858801011115610a4f575f80fd5b836020870160208301375f602085830101528094505050505092915050565b803560ff811681146109a4575f80fd5b5f805f60608486031215610a90575f80fd5b833567ffffffffffffffff80821115610aa7575f80fd5b610ab3878388016109e5565b94506020860135915080821115610ac8575f80fd5b50610ad5868287016109e5565b925050610ae460408501610a6e565b90509250925092565b5f805f60608486031215610aff575f80fd5b610b088461098e565b9250610b166020850161098e565b9150604084013590509250925092565b5f60208284031215610b36575f80fd5b6108f08261098e565b5f805f805f805f60e0888a031215610b55575f80fd5b610b5e8861098e565b9650610b6c6020890161098e565b95506040880135945060608801359350610b8860808901610a6e565b925060a0880135915060c0880135905092959891949750929550565b5f8060408385031215610bb5575f80fd5b610bbe8361098e565b9150610bcc6020840161098e565b90509250929050565b600181811c90821680610be957607f821691505b602082108103610c0757634e487b7160e01b5f52602260045260245ffd5b50919050565b601f821115610c5457805f5260205f20601f840160051c81016020851015610c325750805b601f840160051c820191505b81811015610c51575f8155600101610c3e565b50505b505050565b815167ffffffffffffffff811115610c7357610c736109d1565b610c8781610c818454610bd5565b84610c0d565b602080601f831160018114610cba575f8415610ca35750858301515b5f19600386901b1c1916600185901b178555610d11565b5f85815260208120601f198616915b82811015610ce857888601518255948401946001909101908401610cc9565b5085821015610d0557878501515f19600388901b60f8161c191681555b505060018460011b0185555b505050505050565b634e487b7160e01b5f52601160045260245ffd5b5f60018201610d3e57610d3e610d19565b5060010190565b5f808354610d5281610bd5565b60018281168015610d6a5760018114610d7f57610dab565b60ff1984168752821515830287019450610dab565b875f526020805f205f5b85811015610da25781548a820152908401908201610d89565b50505082870194505b50929695505050505050565b8181038181111561030957610309610d19565b8082018082111561030957610309610d1956fea2646970667358221220dadb91b32a6298680d5ea18d37955b10b6c2867bc14b579fd9e8271e81a3cc9364736f6c63430008190033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x0FW_\x80\xFD[P`\x046\x10a\0\xCBW_5`\xE0\x1C\x80c6D\xE5\x15\x11a\0\x88W\x80c\x95\xD8\x9BA\x11a\0cW\x80c\x95\xD8\x9BA\x14a\x01\xAEW\x80c\xA9\x05\x9C\xBB\x14a\x01\xB6W\x80c\xD5\x05\xAC\xCF\x14a\x01\xC9W\x80c\xDDb\xED>\x14a\x01\xDCW_\x80\xFD[\x80c6D\xE5\x15\x14a\x01_W\x80cp\xA0\x821\x14a\x01gW\x80c~\xCE\xBE\0\x14a\x01\x8FW_\x80\xFD[\x80c\x06\xFD\xDE\x03\x14a\0\xCFW\x80c\t^\xA7\xB3\x14a\0\xEDW\x80c\x16$\xF6\xC6\x14a\x01\x10W\x80c\x18\x16\r\xDD\x14a\x01%W\x80c#\xB8r\xDD\x14a\x017W\x80c1<\xE5g\x14a\x01JW[_\x80\xFD[a\0\xD7a\x02\x14V[`@Qa\0\xE4\x91\x90a\tYV[`@Q\x80\x91\x03\x90\xF3[a\x01\0a\0\xFB6`\x04a\t\xA9V[a\x02\xA3V[`@Q\x90\x15\x15\x81R` \x01a\0\xE4V[a\x01#a\x01\x1E6`\x04a\n~V[a\x03\x0FV[\0[`\x03T[`@Q\x90\x81R` \x01a\0\xE4V[a\x01\0a\x01E6`\x04a\n\xEDV[a\x03\xADV[`\x02T`@Q`\xFF\x90\x91\x16\x81R` \x01a\0\xE4V[a\x01)a\x04\xBCV[a\x01)a\x01u6`\x04a\x0B&V[`\x01`\x01`\xA0\x1B\x03\x16_\x90\x81R`\x04` R`@\x90 T\x90V[a\x01)a\x01\x9D6`\x04a\x0B&V[`\x08` R_\x90\x81R`@\x90 T\x81V[a\0\xD7a\x04\xE1V[a\x01\0a\x01\xC46`\x04a\t\xA9V[a\x04\xF0V[a\x01#a\x01\xD76`\x04a\x0B?V[a\x05\x84V[a\x01)a\x01\xEA6`\x04a\x0B\xA4V[`\x01`\x01`\xA0\x1B\x03\x91\x82\x16_\x90\x81R`\x05` \x90\x81R`@\x80\x83 \x93\x90\x94\x16\x82R\x91\x90\x91R T\x90V[``_\x80Ta\x02\"\x90a\x0B\xD5V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x02N\x90a\x0B\xD5V[\x80\x15a\x02\x99W\x80`\x1F\x10a\x02pWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x02\x99V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x02|W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x90P\x90V[3_\x81\x81R`\x05` \x90\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x87\x16\x80\x85R\x92R\x80\x83 \x85\x90UQ\x91\x92\x90\x91\x7F\x8C[\xE1\xE5\xEB\xEC}[\xD1OqB}\x1E\x84\xF3\xDD\x03\x14\xC0\xF7\xB2)\x1E[ \n\xC8\xC7\xC3\xB9%\x90a\x02\xFD\x90\x86\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA3P`\x01[\x92\x91PPV[`\tT`\xFF\x16\x15a\x03]W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x13`$\x82\x01Rr\x10S\x14\x91PQ\x16W\xD2S\x92U\x12PS\x12V\x91Q`j\x1B`D\x82\x01R`d\x01[`@Q\x80\x91\x03\x90\xFD[_a\x03h\x84\x82a\x0CYV[P`\x01a\x03u\x83\x82a\x0CYV[P`\x02\x80T`\xFF\x19\x16`\xFF\x83\x16\x17\x90Ua\x03\x8Da\x07\xDCV[`\x06Ua\x03\x98a\x07\xF4V[`\x07UPP`\t\x80T`\xFF\x19\x16`\x01\x17\x90UPV[`\x01`\x01`\xA0\x1B\x03\x83\x16_\x90\x81R`\x05` \x90\x81R`@\x80\x83 3\x84R\x90\x91R\x81 T_\x19\x81\x14a\x04\x06Wa\x03\xE2\x81\x84a\x08\x95V[`\x01`\x01`\xA0\x1B\x03\x86\x16_\x90\x81R`\x05` \x90\x81R`@\x80\x83 3\x84R\x90\x91R\x90 U[`\x01`\x01`\xA0\x1B\x03\x85\x16_\x90\x81R`\x04` R`@\x90 Ta\x04(\x90\x84a\x08\x95V[`\x01`\x01`\xA0\x1B\x03\x80\x87\x16_\x90\x81R`\x04` R`@\x80\x82 \x93\x90\x93U\x90\x86\x16\x81R Ta\x04V\x90\x84a\x08\xF7V[`\x01`\x01`\xA0\x1B\x03\x80\x86\x16_\x81\x81R`\x04` R`@\x90\x81\x90 \x93\x90\x93U\x91Q\x90\x87\x16\x90\x7F\xDD\xF2R\xAD\x1B\xE2\xC8\x9Bi\xC2\xB0h\xFC7\x8D\xAA\x95+\xA7\xF1c\xC4\xA1\x16(\xF5ZM\xF5#\xB3\xEF\x90a\x04\xA9\x90\x87\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA3P`\x01\x94\x93PPPPV[_`\x06Ta\x04\xC8a\x07\xDCV[\x14a\x04\xDAWa\x04\xD5a\x07\xF4V[\x90P\x90V[P`\x07T\x90V[```\x01\x80Ta\x02\"\x90a\x0B\xD5V[3_\x90\x81R`\x04` R`@\x81 Ta\x05\t\x90\x83a\x08\x95V[3_\x90\x81R`\x04` R`@\x80\x82 \x92\x90\x92U`\x01`\x01`\xA0\x1B\x03\x85\x16\x81R Ta\x054\x90\x83a\x08\xF7V[`\x01`\x01`\xA0\x1B\x03\x84\x16_\x81\x81R`\x04` R`@\x90\x81\x90 \x92\x90\x92U\x90Q3\x90\x7F\xDD\xF2R\xAD\x1B\xE2\xC8\x9Bi\xC2\xB0h\xFC7\x8D\xAA\x95+\xA7\xF1c\xC4\xA1\x16(\xF5ZM\xF5#\xB3\xEF\x90a\x02\xFD\x90\x86\x81R` \x01\x90V[B\x84\x10\x15a\x05\xD4W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x17`$\x82\x01R\x7FPERMIT_DEADLINE_EXPIRED\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x03TV[_`\x01a\x05\xDFa\x04\xBCV[`\x01`\x01`\xA0\x1B\x03\x8A\x16_\x90\x81R`\x08` R`@\x81 \x80T\x7Fnq\xED\xAE\x12\xB1\xB9\x7FM\x1F`7\x0F\xEF\x10\x10_\xA2\xFA\xAE\x01&\x11J\x16\x9Cd\x84]a&\xC9\x92\x8D\x92\x8D\x92\x8D\x92\x90\x91\x90a\x06,\x83a\r-V[\x90\x91UP`@\x80Q` \x81\x01\x96\x90\x96R`\x01`\x01`\xA0\x1B\x03\x94\x85\x16\x90\x86\x01R\x92\x90\x91\x16``\x84\x01R`\x80\x83\x01R`\xA0\x82\x01R`\xC0\x81\x01\x88\x90R`\xE0\x01`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 `@Q` \x01a\x06\xA5\x92\x91\x90a\x19\x01`\xF0\x1B\x81R`\x02\x81\x01\x92\x90\x92R`\"\x82\x01R`B\x01\x90V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x82\x82R\x80Q` \x91\x82\x01 _\x84R\x90\x83\x01\x80\x83RR`\xFF\x87\x16\x90\x82\x01R``\x81\x01\x85\x90R`\x80\x81\x01\x84\x90R`\xA0\x01` `@Q` \x81\x03\x90\x80\x84\x03\x90\x85Z\xFA\x15\x80\x15a\x07\0W=_\x80>=_\xFD[PP`@Q`\x1F\x19\x01Q\x91PP`\x01`\x01`\xA0\x1B\x03\x81\x16\x15\x80\x15\x90a\x076WP\x87`\x01`\x01`\xA0\x1B\x03\x16\x81`\x01`\x01`\xA0\x1B\x03\x16\x14[a\x07sW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0E`$\x82\x01Rm$\xA7+ \xA6$\xA2/\xA9\xA4\xA3\xA7\"\xA9`\x91\x1B`D\x82\x01R`d\x01a\x03TV[`\x01`\x01`\xA0\x1B\x03\x81\x81\x16_\x90\x81R`\x05` \x90\x81R`@\x80\x83 \x8B\x85\x16\x80\x85R\x90\x83R\x92\x81\x90 \x8A\x90UQ\x89\x81R\x91\x92\x8B\x16\x91\x7F\x8C[\xE1\xE5\xEB\xEC}[\xD1OqB}\x1E\x84\xF3\xDD\x03\x14\xC0\xF7\xB2)\x1E[ \n\xC8\xC7\xC3\xB9%\x91\x01`@Q\x80\x91\x03\x90\xA3PPPPPPPPV[_a\tU\x80a\x07\xEDc\xFF\xFF\xFF\xFF\x82\x16V[\x92PPP\x90V[_\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F_`@Qa\x08$\x91\x90a\rEV[`@Q\x80\x91\x03\x90 \x7F\xC8\x9E\xFD\xAAT\xC0\xF2\x0Cz\xDFa(\x82\xDF\tP\xF5\xA9Qc~\x03\x07\xCD\xCBLg/)\x8B\x8B\xC6a\x08Ua\x07\xDCV[`@\x80Q` \x81\x01\x95\x90\x95R\x84\x01\x92\x90\x92R``\x83\x01R`\x80\x82\x01R0`\xA0\x82\x01R`\xC0\x01`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P\x90V[_\x81\x83\x10\x15a\x08\xE6W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7FERC20: subtraction underflow\0\0\0\0`D\x82\x01R`d\x01a\x03TV[a\x08\xF0\x82\x84a\r\xB7V[\x93\x92PPPV[_\x80a\t\x03\x83\x85a\r\xCAV[\x90P\x83\x81\x10\x15a\x08\xF0W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x18`$\x82\x01R\x7FERC20: addition overflow\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x03TV[F\x90V[` \x81R_\x82Q\x80` \x84\x01R\x80` \x85\x01`@\x85\x01^_`@\x82\x85\x01\x01R`@`\x1F\x19`\x1F\x83\x01\x16\x84\x01\x01\x91PP\x92\x91PPV[\x805`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\t\xA4W_\x80\xFD[\x91\x90PV[_\x80`@\x83\x85\x03\x12\x15a\t\xBAW_\x80\xFD[a\t\xC3\x83a\t\x8EV[\x94` \x93\x90\x93\x015\x93PPPV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[_\x82`\x1F\x83\x01\x12a\t\xF4W_\x80\xFD[\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15a\n\x0FWa\n\x0Fa\t\xD1V[`@Q`\x1F\x83\x01`\x1F\x19\x90\x81\x16`?\x01\x16\x81\x01\x90\x82\x82\x11\x81\x83\x10\x17\x15a\n7Wa\n7a\t\xD1V[\x81`@R\x83\x81R\x86` \x85\x88\x01\x01\x11\x15a\nOW_\x80\xFD[\x83` \x87\x01` \x83\x017_` \x85\x83\x01\x01R\x80\x94PPPPP\x92\x91PPV[\x805`\xFF\x81\x16\x81\x14a\t\xA4W_\x80\xFD[_\x80_``\x84\x86\x03\x12\x15a\n\x90W_\x80\xFD[\x835g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15a\n\xA7W_\x80\xFD[a\n\xB3\x87\x83\x88\x01a\t\xE5V[\x94P` \x86\x015\x91P\x80\x82\x11\x15a\n\xC8W_\x80\xFD[Pa\n\xD5\x86\x82\x87\x01a\t\xE5V[\x92PPa\n\xE4`@\x85\x01a\nnV[\x90P\x92P\x92P\x92V[_\x80_``\x84\x86\x03\x12\x15a\n\xFFW_\x80\xFD[a\x0B\x08\x84a\t\x8EV[\x92Pa\x0B\x16` \x85\x01a\t\x8EV[\x91P`@\x84\x015\x90P\x92P\x92P\x92V[_` \x82\x84\x03\x12\x15a\x0B6W_\x80\xFD[a\x08\xF0\x82a\t\x8EV[_\x80_\x80_\x80_`\xE0\x88\x8A\x03\x12\x15a\x0BUW_\x80\xFD[a\x0B^\x88a\t\x8EV[\x96Pa\x0Bl` \x89\x01a\t\x8EV[\x95P`@\x88\x015\x94P``\x88\x015\x93Pa\x0B\x88`\x80\x89\x01a\nnV[\x92P`\xA0\x88\x015\x91P`\xC0\x88\x015\x90P\x92\x95\x98\x91\x94\x97P\x92\x95PV[_\x80`@\x83\x85\x03\x12\x15a\x0B\xB5W_\x80\xFD[a\x0B\xBE\x83a\t\x8EV[\x91Pa\x0B\xCC` \x84\x01a\t\x8EV[\x90P\x92P\x92\x90PV[`\x01\x81\x81\x1C\x90\x82\x16\x80a\x0B\xE9W`\x7F\x82\x16\x91P[` \x82\x10\x81\x03a\x0C\x07WcNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[P\x91\x90PV[`\x1F\x82\x11\x15a\x0CTW\x80_R` _ `\x1F\x84\x01`\x05\x1C\x81\x01` \x85\x10\x15a\x0C2WP\x80[`\x1F\x84\x01`\x05\x1C\x82\x01\x91P[\x81\x81\x10\x15a\x0CQW_\x81U`\x01\x01a\x0C>V[PP[PPPV[\x81Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x0CsWa\x0Csa\t\xD1V[a\x0C\x87\x81a\x0C\x81\x84Ta\x0B\xD5V[\x84a\x0C\rV[` \x80`\x1F\x83\x11`\x01\x81\x14a\x0C\xBAW_\x84\x15a\x0C\xA3WP\x85\x83\x01Q[_\x19`\x03\x86\x90\x1B\x1C\x19\x16`\x01\x85\x90\x1B\x17\x85Ua\r\x11V[_\x85\x81R` \x81 `\x1F\x19\x86\x16\x91[\x82\x81\x10\x15a\x0C\xE8W\x88\x86\x01Q\x82U\x94\x84\x01\x94`\x01\x90\x91\x01\x90\x84\x01a\x0C\xC9V[P\x85\x82\x10\x15a\r\x05W\x87\x85\x01Q_\x19`\x03\x88\x90\x1B`\xF8\x16\x1C\x19\x16\x81U[PP`\x01\x84`\x01\x1B\x01\x85U[PPPPPPV[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[_`\x01\x82\x01a\r>Wa\r>a\r\x19V[P`\x01\x01\x90V[_\x80\x83Ta\rR\x81a\x0B\xD5V[`\x01\x82\x81\x16\x80\x15a\rjW`\x01\x81\x14a\r\x7FWa\r\xABV[`\xFF\x19\x84\x16\x87R\x82\x15\x15\x83\x02\x87\x01\x94Pa\r\xABV[\x87_R` \x80_ _[\x85\x81\x10\x15a\r\xA2W\x81T\x8A\x82\x01R\x90\x84\x01\x90\x82\x01a\r\x89V[PPP\x82\x87\x01\x94P[P\x92\x96\x95PPPPPPV[\x81\x81\x03\x81\x81\x11\x15a\x03\tWa\x03\ta\r\x19V[\x80\x82\x01\x80\x82\x11\x15a\x03\tWa\x03\ta\r\x19V\xFE\xA2dipfsX\"\x12 \xDA\xDB\x91\xB3*b\x98h\r^\xA1\x8D7\x95[\x10\xB6\xC2\x86{\xC1KW\x9F\xD9\xE8'\x1E\x81\xA3\xCC\x93dsolcC\0\x08\x19\x003",
    );
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	/**Event with signature `Approval(address,address,uint256)` and selector `0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925`.
	```solidity
	event Approval(address indexed owner, address indexed spender, uint256 value);
	```*/
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
	#[derive(Clone)]
	pub struct Approval {
		#[allow(missing_docs)]
		pub owner: alloy::sol_types::private::Address,
		#[allow(missing_docs)]
		pub spender: alloy::sol_types::private::Address,
		#[allow(missing_docs)]
		pub value: alloy::sol_types::private::primitives::aliases::U256,
	}
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
	const _: () = {
		use alloy::sol_types as alloy_sol_types;
		#[automatically_derived]
		impl alloy_sol_types::SolEvent for Approval {
			type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
			type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
			type TopicList = (
				alloy_sol_types::sol_data::FixedBytes<32>,
				alloy::sol_types::sol_data::Address,
				alloy::sol_types::sol_data::Address,
			);
			const SIGNATURE: &'static str = "Approval(address,address,uint256)";
			const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
				140u8, 91u8, 225u8, 229u8, 235u8, 236u8, 125u8, 91u8, 209u8, 79u8, 113u8, 66u8, 125u8, 30u8, 132u8,
				243u8, 221u8, 3u8, 20u8, 192u8, 247u8, 178u8, 41u8, 30u8, 91u8, 32u8, 10u8, 200u8, 199u8, 195u8, 185u8,
				37u8,
			]);
			const ANONYMOUS: bool = false;
			#[allow(unused_variables)]
			#[inline]
			fn new(
				topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
				data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
			) -> Self {
				Self { owner: topics.1, spender: topics.2, value: data.0 }
			}
			#[inline]
			fn check_signature(
				topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
			) -> alloy_sol_types::Result<()> {
				if topics.0 != Self::SIGNATURE_HASH {
					return Err(alloy_sol_types::Error::invalid_event_signature_hash(
						Self::SIGNATURE,
						topics.0,
						Self::SIGNATURE_HASH,
					));
				}
				Ok(())
			}
			#[inline]
			fn tokenize_body(&self) -> Self::DataToken<'_> {
				(<alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(&self.value),)
			}
			#[inline]
			fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
				(Self::SIGNATURE_HASH.into(), self.owner.clone(), self.spender.clone())
			}
			#[inline]
			fn encode_topics_raw(
				&self,
				out: &mut [alloy_sol_types::abi::token::WordToken],
			) -> alloy_sol_types::Result<()> {
				if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
					return Err(alloy_sol_types::Error::Overrun);
				}
				out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
				out[1usize] =
					<alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(&self.owner);
				out[2usize] =
					<alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(&self.spender);
				Ok(())
			}
		}
		#[automatically_derived]
		impl alloy_sol_types::private::IntoLogData for Approval {
			fn to_log_data(&self) -> alloy_sol_types::private::LogData {
				From::from(self)
			}
			fn into_log_data(self) -> alloy_sol_types::private::LogData {
				From::from(&self)
			}
		}
		#[automatically_derived]
		impl From<&Approval> for alloy_sol_types::private::LogData {
			#[inline]
			fn from(this: &Approval) -> alloy_sol_types::private::LogData {
				alloy_sol_types::SolEvent::encode_log_data(this)
			}
		}
	};
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	/**Event with signature `Transfer(address,address,uint256)` and selector `0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef`.
	```solidity
	event Transfer(address indexed from, address indexed to, uint256 value);
	```*/
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
	#[derive(Clone)]
	pub struct Transfer {
		#[allow(missing_docs)]
		pub from: alloy::sol_types::private::Address,
		#[allow(missing_docs)]
		pub to: alloy::sol_types::private::Address,
		#[allow(missing_docs)]
		pub value: alloy::sol_types::private::primitives::aliases::U256,
	}
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
	const _: () = {
		use alloy::sol_types as alloy_sol_types;
		#[automatically_derived]
		impl alloy_sol_types::SolEvent for Transfer {
			type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
			type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
			type TopicList = (
				alloy_sol_types::sol_data::FixedBytes<32>,
				alloy::sol_types::sol_data::Address,
				alloy::sol_types::sol_data::Address,
			);
			const SIGNATURE: &'static str = "Transfer(address,address,uint256)";
			const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
				221u8, 242u8, 82u8, 173u8, 27u8, 226u8, 200u8, 155u8, 105u8, 194u8, 176u8, 104u8, 252u8, 55u8, 141u8,
				170u8, 149u8, 43u8, 167u8, 241u8, 99u8, 196u8, 161u8, 22u8, 40u8, 245u8, 90u8, 77u8, 245u8, 35u8,
				179u8, 239u8,
			]);
			const ANONYMOUS: bool = false;
			#[allow(unused_variables)]
			#[inline]
			fn new(
				topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
				data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
			) -> Self {
				Self { from: topics.1, to: topics.2, value: data.0 }
			}
			#[inline]
			fn check_signature(
				topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
			) -> alloy_sol_types::Result<()> {
				if topics.0 != Self::SIGNATURE_HASH {
					return Err(alloy_sol_types::Error::invalid_event_signature_hash(
						Self::SIGNATURE,
						topics.0,
						Self::SIGNATURE_HASH,
					));
				}
				Ok(())
			}
			#[inline]
			fn tokenize_body(&self) -> Self::DataToken<'_> {
				(<alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(&self.value),)
			}
			#[inline]
			fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
				(Self::SIGNATURE_HASH.into(), self.from.clone(), self.to.clone())
			}
			#[inline]
			fn encode_topics_raw(
				&self,
				out: &mut [alloy_sol_types::abi::token::WordToken],
			) -> alloy_sol_types::Result<()> {
				if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
					return Err(alloy_sol_types::Error::Overrun);
				}
				out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
				out[1usize] =
					<alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(&self.from);
				out[2usize] =
					<alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(&self.to);
				Ok(())
			}
		}
		#[automatically_derived]
		impl alloy_sol_types::private::IntoLogData for Transfer {
			fn to_log_data(&self) -> alloy_sol_types::private::LogData {
				From::from(self)
			}
			fn into_log_data(self) -> alloy_sol_types::private::LogData {
				From::from(&self)
			}
		}
		#[automatically_derived]
		impl From<&Transfer> for alloy_sol_types::private::LogData {
			#[inline]
			fn from(this: &Transfer) -> alloy_sol_types::private::LogData {
				alloy_sol_types::SolEvent::encode_log_data(this)
			}
		}
	};
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	/**Function with signature `DOMAIN_SEPARATOR()` and selector `0x3644e515`.
	```solidity
	function DOMAIN_SEPARATOR() external view returns (bytes32);
	```*/
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct DOMAIN_SEPARATORCall;
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	///Container type for the return parameters of the [`DOMAIN_SEPARATOR()`](DOMAIN_SEPARATORCall) function.
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct DOMAIN_SEPARATORReturn {
		#[allow(missing_docs)]
		pub _0: alloy::sol_types::private::FixedBytes<32>,
	}
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
	const _: () = {
		use alloy::sol_types as alloy_sol_types;
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = ();
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = ();
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<DOMAIN_SEPARATORCall> for UnderlyingRustTuple<'_> {
				fn from(value: DOMAIN_SEPARATORCall) -> Self {
					()
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for DOMAIN_SEPARATORCall {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self
				}
			}
		}
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<DOMAIN_SEPARATORReturn> for UnderlyingRustTuple<'_> {
				fn from(value: DOMAIN_SEPARATORReturn) -> Self {
					(value._0,)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for DOMAIN_SEPARATORReturn {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self { _0: tuple.0 }
				}
			}
		}
		#[automatically_derived]
		impl alloy_sol_types::SolCall for DOMAIN_SEPARATORCall {
			type Parameters<'a> = ();
			type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
			type Return = alloy::sol_types::private::FixedBytes<32>;
			type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
			type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
			const SIGNATURE: &'static str = "DOMAIN_SEPARATOR()";
			const SELECTOR: [u8; 4] = [54u8, 68u8, 229u8, 21u8];
			#[inline]
			fn new<'a>(tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType) -> Self {
				tuple.into()
			}
			#[inline]
			fn tokenize(&self) -> Self::Token<'_> {
				()
			}
			#[inline]
			fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
				(<alloy::sol_types::sol_data::FixedBytes<32> as alloy_sol_types::SolType>::tokenize(ret),)
			}
			#[inline]
			fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(data).map(|r| {
					let r: DOMAIN_SEPARATORReturn = r.into();
					r._0
				})
			}
			#[inline]
			fn abi_decode_returns_validate(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence_validate(data).map(|r| {
					let r: DOMAIN_SEPARATORReturn = r.into();
					r._0
				})
			}
		}
	};
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	/**Function with signature `allowance(address,address)` and selector `0xdd62ed3e`.
	```solidity
	function allowance(address owner, address spender) external view returns (uint256);
	```*/
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct allowanceCall {
		#[allow(missing_docs)]
		pub owner: alloy::sol_types::private::Address,
		#[allow(missing_docs)]
		pub spender: alloy::sol_types::private::Address,
	}
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	///Container type for the return parameters of the [`allowance(address,address)`](allowanceCall) function.
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct allowanceReturn {
		#[allow(missing_docs)]
		pub _0: alloy::sol_types::private::primitives::aliases::U256,
	}
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
	const _: () = {
		use alloy::sol_types as alloy_sol_types;
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::Address);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, alloy::sol_types::private::Address);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<allowanceCall> for UnderlyingRustTuple<'_> {
				fn from(value: allowanceCall) -> Self {
					(value.owner, value.spender)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for allowanceCall {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self { owner: tuple.0, spender: tuple.1 }
				}
			}
		}
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<allowanceReturn> for UnderlyingRustTuple<'_> {
				fn from(value: allowanceReturn) -> Self {
					(value._0,)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for allowanceReturn {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self { _0: tuple.0 }
				}
			}
		}
		#[automatically_derived]
		impl alloy_sol_types::SolCall for allowanceCall {
			type Parameters<'a> = (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::Address);
			type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
			type Return = alloy::sol_types::private::primitives::aliases::U256;
			type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
			type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
			const SIGNATURE: &'static str = "allowance(address,address)";
			const SELECTOR: [u8; 4] = [221u8, 98u8, 237u8, 62u8];
			#[inline]
			fn new<'a>(tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType) -> Self {
				tuple.into()
			}
			#[inline]
			fn tokenize(&self) -> Self::Token<'_> {
				(
					<alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(&self.owner),
					<alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(&self.spender),
				)
			}
			#[inline]
			fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
				(<alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(ret),)
			}
			#[inline]
			fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(data).map(|r| {
					let r: allowanceReturn = r.into();
					r._0
				})
			}
			#[inline]
			fn abi_decode_returns_validate(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence_validate(data).map(|r| {
					let r: allowanceReturn = r.into();
					r._0
				})
			}
		}
	};
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	/**Function with signature `approve(address,uint256)` and selector `0x095ea7b3`.
	```solidity
	function approve(address spender, uint256 amount) external returns (bool);
	```*/
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct approveCall {
		#[allow(missing_docs)]
		pub spender: alloy::sol_types::private::Address,
		#[allow(missing_docs)]
		pub amount: alloy::sol_types::private::primitives::aliases::U256,
	}
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	///Container type for the return parameters of the [`approve(address,uint256)`](approveCall) function.
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct approveReturn {
		#[allow(missing_docs)]
		pub _0: bool,
	}
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
	const _: () = {
		use alloy::sol_types as alloy_sol_types;
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::Uint<256>);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> =
				(alloy::sol_types::private::Address, alloy::sol_types::private::primitives::aliases::U256);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<approveCall> for UnderlyingRustTuple<'_> {
				fn from(value: approveCall) -> Self {
					(value.spender, value.amount)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for approveCall {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self { spender: tuple.0, amount: tuple.1 }
				}
			}
		}
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = (bool,);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<approveReturn> for UnderlyingRustTuple<'_> {
				fn from(value: approveReturn) -> Self {
					(value._0,)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for approveReturn {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self { _0: tuple.0 }
				}
			}
		}
		#[automatically_derived]
		impl alloy_sol_types::SolCall for approveCall {
			type Parameters<'a> = (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::Uint<256>);
			type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
			type Return = bool;
			type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
			type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
			const SIGNATURE: &'static str = "approve(address,uint256)";
			const SELECTOR: [u8; 4] = [9u8, 94u8, 167u8, 179u8];
			#[inline]
			fn new<'a>(tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType) -> Self {
				tuple.into()
			}
			#[inline]
			fn tokenize(&self) -> Self::Token<'_> {
				(
					<alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(&self.spender),
					<alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(&self.amount),
				)
			}
			#[inline]
			fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
				(<alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(ret),)
			}
			#[inline]
			fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(data).map(|r| {
					let r: approveReturn = r.into();
					r._0
				})
			}
			#[inline]
			fn abi_decode_returns_validate(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence_validate(data).map(|r| {
					let r: approveReturn = r.into();
					r._0
				})
			}
		}
	};
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	/**Function with signature `balanceOf(address)` and selector `0x70a08231`.
	```solidity
	function balanceOf(address owner) external view returns (uint256);
	```*/
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct balanceOfCall {
		#[allow(missing_docs)]
		pub owner: alloy::sol_types::private::Address,
	}
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	///Container type for the return parameters of the [`balanceOf(address)`](balanceOfCall) function.
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct balanceOfReturn {
		#[allow(missing_docs)]
		pub _0: alloy::sol_types::private::primitives::aliases::U256,
	}
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
	const _: () = {
		use alloy::sol_types as alloy_sol_types;
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<balanceOfCall> for UnderlyingRustTuple<'_> {
				fn from(value: balanceOfCall) -> Self {
					(value.owner,)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for balanceOfCall {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self { owner: tuple.0 }
				}
			}
		}
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<balanceOfReturn> for UnderlyingRustTuple<'_> {
				fn from(value: balanceOfReturn) -> Self {
					(value._0,)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for balanceOfReturn {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self { _0: tuple.0 }
				}
			}
		}
		#[automatically_derived]
		impl alloy_sol_types::SolCall for balanceOfCall {
			type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
			type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
			type Return = alloy::sol_types::private::primitives::aliases::U256;
			type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
			type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
			const SIGNATURE: &'static str = "balanceOf(address)";
			const SELECTOR: [u8; 4] = [112u8, 160u8, 130u8, 49u8];
			#[inline]
			fn new<'a>(tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType) -> Self {
				tuple.into()
			}
			#[inline]
			fn tokenize(&self) -> Self::Token<'_> {
				(<alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(&self.owner),)
			}
			#[inline]
			fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
				(<alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(ret),)
			}
			#[inline]
			fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(data).map(|r| {
					let r: balanceOfReturn = r.into();
					r._0
				})
			}
			#[inline]
			fn abi_decode_returns_validate(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence_validate(data).map(|r| {
					let r: balanceOfReturn = r.into();
					r._0
				})
			}
		}
	};
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	/**Function with signature `decimals()` and selector `0x313ce567`.
	```solidity
	function decimals() external view returns (uint8);
	```*/
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct decimalsCall;
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	///Container type for the return parameters of the [`decimals()`](decimalsCall) function.
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct decimalsReturn {
		#[allow(missing_docs)]
		pub _0: u8,
	}
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
	const _: () = {
		use alloy::sol_types as alloy_sol_types;
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = ();
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = ();
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<decimalsCall> for UnderlyingRustTuple<'_> {
				fn from(value: decimalsCall) -> Self {
					()
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for decimalsCall {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self
				}
			}
		}
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = (u8,);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<decimalsReturn> for UnderlyingRustTuple<'_> {
				fn from(value: decimalsReturn) -> Self {
					(value._0,)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for decimalsReturn {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self { _0: tuple.0 }
				}
			}
		}
		#[automatically_derived]
		impl alloy_sol_types::SolCall for decimalsCall {
			type Parameters<'a> = ();
			type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
			type Return = u8;
			type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
			type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
			const SIGNATURE: &'static str = "decimals()";
			const SELECTOR: [u8; 4] = [49u8, 60u8, 229u8, 103u8];
			#[inline]
			fn new<'a>(tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType) -> Self {
				tuple.into()
			}
			#[inline]
			fn tokenize(&self) -> Self::Token<'_> {
				()
			}
			#[inline]
			fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
				(<alloy::sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::tokenize(ret),)
			}
			#[inline]
			fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(data).map(|r| {
					let r: decimalsReturn = r.into();
					r._0
				})
			}
			#[inline]
			fn abi_decode_returns_validate(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence_validate(data).map(|r| {
					let r: decimalsReturn = r.into();
					r._0
				})
			}
		}
	};
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	/**Function with signature `initialize(string,string,uint8)` and selector `0x1624f6c6`.
	```solidity
	function initialize(string memory name_, string memory symbol_, uint8 decimals_) external;
	```*/
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct initializeCall {
		#[allow(missing_docs)]
		pub name_: alloy::sol_types::private::String,
		#[allow(missing_docs)]
		pub symbol_: alloy::sol_types::private::String,
		#[allow(missing_docs)]
		pub decimals_: u8,
	}
	///Container type for the return parameters of the [`initialize(string,string,uint8)`](initializeCall) function.
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct initializeReturn {}
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
	const _: () = {
		use alloy::sol_types as alloy_sol_types;
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (
				alloy::sol_types::sol_data::String,
				alloy::sol_types::sol_data::String,
				alloy::sol_types::sol_data::Uint<8>,
			);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String, alloy::sol_types::private::String, u8);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<initializeCall> for UnderlyingRustTuple<'_> {
				fn from(value: initializeCall) -> Self {
					(value.name_, value.symbol_, value.decimals_)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeCall {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self { name_: tuple.0, symbol_: tuple.1, decimals_: tuple.2 }
				}
			}
		}
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = ();
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = ();
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<initializeReturn> for UnderlyingRustTuple<'_> {
				fn from(value: initializeReturn) -> Self {
					()
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeReturn {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self {}
				}
			}
		}
		impl initializeReturn {
			fn _tokenize(&self) -> <initializeCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
				()
			}
		}
		#[automatically_derived]
		impl alloy_sol_types::SolCall for initializeCall {
			type Parameters<'a> = (
				alloy::sol_types::sol_data::String,
				alloy::sol_types::sol_data::String,
				alloy::sol_types::sol_data::Uint<8>,
			);
			type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
			type Return = initializeReturn;
			type ReturnTuple<'a> = ();
			type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
			const SIGNATURE: &'static str = "initialize(string,string,uint8)";
			const SELECTOR: [u8; 4] = [22u8, 36u8, 246u8, 198u8];
			#[inline]
			fn new<'a>(tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType) -> Self {
				tuple.into()
			}
			#[inline]
			fn tokenize(&self) -> Self::Token<'_> {
				(
					<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(&self.name_),
					<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(&self.symbol_),
					<alloy::sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::tokenize(&self.decimals_),
				)
			}
			#[inline]
			fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
				initializeReturn::_tokenize(ret)
			}
			#[inline]
			fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(data).map(Into::into)
			}
			#[inline]
			fn abi_decode_returns_validate(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence_validate(data).map(Into::into)
			}
		}
	};
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	/**Function with signature `name()` and selector `0x06fdde03`.
	```solidity
	function name() external view returns (string memory);
	```*/
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct nameCall;
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	///Container type for the return parameters of the [`name()`](nameCall) function.
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct nameReturn {
		#[allow(missing_docs)]
		pub _0: alloy::sol_types::private::String,
	}
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
	const _: () = {
		use alloy::sol_types as alloy_sol_types;
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = ();
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = ();
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<nameCall> for UnderlyingRustTuple<'_> {
				fn from(value: nameCall) -> Self {
					()
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for nameCall {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self
				}
			}
		}
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<nameReturn> for UnderlyingRustTuple<'_> {
				fn from(value: nameReturn) -> Self {
					(value._0,)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for nameReturn {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self { _0: tuple.0 }
				}
			}
		}
		#[automatically_derived]
		impl alloy_sol_types::SolCall for nameCall {
			type Parameters<'a> = ();
			type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
			type Return = alloy::sol_types::private::String;
			type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
			type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
			const SIGNATURE: &'static str = "name()";
			const SELECTOR: [u8; 4] = [6u8, 253u8, 222u8, 3u8];
			#[inline]
			fn new<'a>(tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType) -> Self {
				tuple.into()
			}
			#[inline]
			fn tokenize(&self) -> Self::Token<'_> {
				()
			}
			#[inline]
			fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
				(<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(ret),)
			}
			#[inline]
			fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(data).map(|r| {
					let r: nameReturn = r.into();
					r._0
				})
			}
			#[inline]
			fn abi_decode_returns_validate(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence_validate(data).map(|r| {
					let r: nameReturn = r.into();
					r._0
				})
			}
		}
	};
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	/**Function with signature `nonces(address)` and selector `0x7ecebe00`.
	```solidity
	function nonces(address) external view returns (uint256);
	```*/
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct noncesCall(pub alloy::sol_types::private::Address);
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	///Container type for the return parameters of the [`nonces(address)`](noncesCall) function.
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct noncesReturn {
		#[allow(missing_docs)]
		pub _0: alloy::sol_types::private::primitives::aliases::U256,
	}
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
	const _: () = {
		use alloy::sol_types as alloy_sol_types;
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<noncesCall> for UnderlyingRustTuple<'_> {
				fn from(value: noncesCall) -> Self {
					(value.0,)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for noncesCall {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self(tuple.0)
				}
			}
		}
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<noncesReturn> for UnderlyingRustTuple<'_> {
				fn from(value: noncesReturn) -> Self {
					(value._0,)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for noncesReturn {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self { _0: tuple.0 }
				}
			}
		}
		#[automatically_derived]
		impl alloy_sol_types::SolCall for noncesCall {
			type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
			type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
			type Return = alloy::sol_types::private::primitives::aliases::U256;
			type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
			type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
			const SIGNATURE: &'static str = "nonces(address)";
			const SELECTOR: [u8; 4] = [126u8, 206u8, 190u8, 0u8];
			#[inline]
			fn new<'a>(tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType) -> Self {
				tuple.into()
			}
			#[inline]
			fn tokenize(&self) -> Self::Token<'_> {
				(<alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(&self.0),)
			}
			#[inline]
			fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
				(<alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(ret),)
			}
			#[inline]
			fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(data).map(|r| {
					let r: noncesReturn = r.into();
					r._0
				})
			}
			#[inline]
			fn abi_decode_returns_validate(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence_validate(data).map(|r| {
					let r: noncesReturn = r.into();
					r._0
				})
			}
		}
	};
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	/**Function with signature `permit(address,address,uint256,uint256,uint8,bytes32,bytes32)` and selector `0xd505accf`.
	```solidity
	function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;
	```*/
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct permitCall {
		#[allow(missing_docs)]
		pub owner: alloy::sol_types::private::Address,
		#[allow(missing_docs)]
		pub spender: alloy::sol_types::private::Address,
		#[allow(missing_docs)]
		pub value: alloy::sol_types::private::primitives::aliases::U256,
		#[allow(missing_docs)]
		pub deadline: alloy::sol_types::private::primitives::aliases::U256,
		#[allow(missing_docs)]
		pub v: u8,
		#[allow(missing_docs)]
		pub r: alloy::sol_types::private::FixedBytes<32>,
		#[allow(missing_docs)]
		pub s: alloy::sol_types::private::FixedBytes<32>,
	}
	///Container type for the return parameters of the [`permit(address,address,uint256,uint256,uint8,bytes32,bytes32)`](permitCall) function.
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct permitReturn {}
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
	const _: () = {
		use alloy::sol_types as alloy_sol_types;
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (
				alloy::sol_types::sol_data::Address,
				alloy::sol_types::sol_data::Address,
				alloy::sol_types::sol_data::Uint<256>,
				alloy::sol_types::sol_data::Uint<256>,
				alloy::sol_types::sol_data::Uint<8>,
				alloy::sol_types::sol_data::FixedBytes<32>,
				alloy::sol_types::sol_data::FixedBytes<32>,
			);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = (
				alloy::sol_types::private::Address,
				alloy::sol_types::private::Address,
				alloy::sol_types::private::primitives::aliases::U256,
				alloy::sol_types::private::primitives::aliases::U256,
				u8,
				alloy::sol_types::private::FixedBytes<32>,
				alloy::sol_types::private::FixedBytes<32>,
			);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<permitCall> for UnderlyingRustTuple<'_> {
				fn from(value: permitCall) -> Self {
					(value.owner, value.spender, value.value, value.deadline, value.v, value.r, value.s)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for permitCall {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self {
						owner: tuple.0,
						spender: tuple.1,
						value: tuple.2,
						deadline: tuple.3,
						v: tuple.4,
						r: tuple.5,
						s: tuple.6,
					}
				}
			}
		}
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = ();
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = ();
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<permitReturn> for UnderlyingRustTuple<'_> {
				fn from(value: permitReturn) -> Self {
					()
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for permitReturn {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self {}
				}
			}
		}
		impl permitReturn {
			fn _tokenize(&self) -> <permitCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
				()
			}
		}
		#[automatically_derived]
		impl alloy_sol_types::SolCall for permitCall {
			type Parameters<'a> = (
				alloy::sol_types::sol_data::Address,
				alloy::sol_types::sol_data::Address,
				alloy::sol_types::sol_data::Uint<256>,
				alloy::sol_types::sol_data::Uint<256>,
				alloy::sol_types::sol_data::Uint<8>,
				alloy::sol_types::sol_data::FixedBytes<32>,
				alloy::sol_types::sol_data::FixedBytes<32>,
			);
			type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
			type Return = permitReturn;
			type ReturnTuple<'a> = ();
			type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
			const SIGNATURE: &'static str = "permit(address,address,uint256,uint256,uint8,bytes32,bytes32)";
			const SELECTOR: [u8; 4] = [213u8, 5u8, 172u8, 207u8];
			#[inline]
			fn new<'a>(tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType) -> Self {
				tuple.into()
			}
			#[inline]
			fn tokenize(&self) -> Self::Token<'_> {
				(
					<alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(&self.owner),
					<alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(&self.spender),
					<alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(&self.value),
					<alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(&self.deadline),
					<alloy::sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::tokenize(&self.v),
					<alloy::sol_types::sol_data::FixedBytes<32> as alloy_sol_types::SolType>::tokenize(&self.r),
					<alloy::sol_types::sol_data::FixedBytes<32> as alloy_sol_types::SolType>::tokenize(&self.s),
				)
			}
			#[inline]
			fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
				permitReturn::_tokenize(ret)
			}
			#[inline]
			fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(data).map(Into::into)
			}
			#[inline]
			fn abi_decode_returns_validate(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence_validate(data).map(Into::into)
			}
		}
	};
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	/**Function with signature `symbol()` and selector `0x95d89b41`.
	```solidity
	function symbol() external view returns (string memory);
	```*/
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct symbolCall;
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	///Container type for the return parameters of the [`symbol()`](symbolCall) function.
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct symbolReturn {
		#[allow(missing_docs)]
		pub _0: alloy::sol_types::private::String,
	}
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
	const _: () = {
		use alloy::sol_types as alloy_sol_types;
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = ();
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = ();
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<symbolCall> for UnderlyingRustTuple<'_> {
				fn from(value: symbolCall) -> Self {
					()
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for symbolCall {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self
				}
			}
		}
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<symbolReturn> for UnderlyingRustTuple<'_> {
				fn from(value: symbolReturn) -> Self {
					(value._0,)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for symbolReturn {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self { _0: tuple.0 }
				}
			}
		}
		#[automatically_derived]
		impl alloy_sol_types::SolCall for symbolCall {
			type Parameters<'a> = ();
			type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
			type Return = alloy::sol_types::private::String;
			type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
			type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
			const SIGNATURE: &'static str = "symbol()";
			const SELECTOR: [u8; 4] = [149u8, 216u8, 155u8, 65u8];
			#[inline]
			fn new<'a>(tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType) -> Self {
				tuple.into()
			}
			#[inline]
			fn tokenize(&self) -> Self::Token<'_> {
				()
			}
			#[inline]
			fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
				(<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(ret),)
			}
			#[inline]
			fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(data).map(|r| {
					let r: symbolReturn = r.into();
					r._0
				})
			}
			#[inline]
			fn abi_decode_returns_validate(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence_validate(data).map(|r| {
					let r: symbolReturn = r.into();
					r._0
				})
			}
		}
	};
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	/**Function with signature `totalSupply()` and selector `0x18160ddd`.
	```solidity
	function totalSupply() external view returns (uint256);
	```*/
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct totalSupplyCall;
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	///Container type for the return parameters of the [`totalSupply()`](totalSupplyCall) function.
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct totalSupplyReturn {
		#[allow(missing_docs)]
		pub _0: alloy::sol_types::private::primitives::aliases::U256,
	}
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
	const _: () = {
		use alloy::sol_types as alloy_sol_types;
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = ();
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = ();
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<totalSupplyCall> for UnderlyingRustTuple<'_> {
				fn from(value: totalSupplyCall) -> Self {
					()
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for totalSupplyCall {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self
				}
			}
		}
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<totalSupplyReturn> for UnderlyingRustTuple<'_> {
				fn from(value: totalSupplyReturn) -> Self {
					(value._0,)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for totalSupplyReturn {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self { _0: tuple.0 }
				}
			}
		}
		#[automatically_derived]
		impl alloy_sol_types::SolCall for totalSupplyCall {
			type Parameters<'a> = ();
			type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
			type Return = alloy::sol_types::private::primitives::aliases::U256;
			type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
			type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
			const SIGNATURE: &'static str = "totalSupply()";
			const SELECTOR: [u8; 4] = [24u8, 22u8, 13u8, 221u8];
			#[inline]
			fn new<'a>(tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType) -> Self {
				tuple.into()
			}
			#[inline]
			fn tokenize(&self) -> Self::Token<'_> {
				()
			}
			#[inline]
			fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
				(<alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(ret),)
			}
			#[inline]
			fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(data).map(|r| {
					let r: totalSupplyReturn = r.into();
					r._0
				})
			}
			#[inline]
			fn abi_decode_returns_validate(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence_validate(data).map(|r| {
					let r: totalSupplyReturn = r.into();
					r._0
				})
			}
		}
	};
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	/**Function with signature `transfer(address,uint256)` and selector `0xa9059cbb`.
	```solidity
	function transfer(address to, uint256 amount) external returns (bool);
	```*/
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct transferCall {
		#[allow(missing_docs)]
		pub to: alloy::sol_types::private::Address,
		#[allow(missing_docs)]
		pub amount: alloy::sol_types::private::primitives::aliases::U256,
	}
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	///Container type for the return parameters of the [`transfer(address,uint256)`](transferCall) function.
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct transferReturn {
		#[allow(missing_docs)]
		pub _0: bool,
	}
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
	const _: () = {
		use alloy::sol_types as alloy_sol_types;
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::Uint<256>);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> =
				(alloy::sol_types::private::Address, alloy::sol_types::private::primitives::aliases::U256);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<transferCall> for UnderlyingRustTuple<'_> {
				fn from(value: transferCall) -> Self {
					(value.to, value.amount)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferCall {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self { to: tuple.0, amount: tuple.1 }
				}
			}
		}
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = (bool,);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<transferReturn> for UnderlyingRustTuple<'_> {
				fn from(value: transferReturn) -> Self {
					(value._0,)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferReturn {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self { _0: tuple.0 }
				}
			}
		}
		#[automatically_derived]
		impl alloy_sol_types::SolCall for transferCall {
			type Parameters<'a> = (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::Uint<256>);
			type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
			type Return = bool;
			type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
			type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
			const SIGNATURE: &'static str = "transfer(address,uint256)";
			const SELECTOR: [u8; 4] = [169u8, 5u8, 156u8, 187u8];
			#[inline]
			fn new<'a>(tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType) -> Self {
				tuple.into()
			}
			#[inline]
			fn tokenize(&self) -> Self::Token<'_> {
				(
					<alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(&self.to),
					<alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(&self.amount),
				)
			}
			#[inline]
			fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
				(<alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(ret),)
			}
			#[inline]
			fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(data).map(|r| {
					let r: transferReturn = r.into();
					r._0
				})
			}
			#[inline]
			fn abi_decode_returns_validate(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence_validate(data).map(|r| {
					let r: transferReturn = r.into();
					r._0
				})
			}
		}
	};
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	/**Function with signature `transferFrom(address,address,uint256)` and selector `0x23b872dd`.
	```solidity
	function transferFrom(address from, address to, uint256 amount) external returns (bool);
	```*/
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct transferFromCall {
		#[allow(missing_docs)]
		pub from: alloy::sol_types::private::Address,
		#[allow(missing_docs)]
		pub to: alloy::sol_types::private::Address,
		#[allow(missing_docs)]
		pub amount: alloy::sol_types::private::primitives::aliases::U256,
	}
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	///Container type for the return parameters of the [`transferFrom(address,address,uint256)`](transferFromCall) function.
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct transferFromReturn {
		#[allow(missing_docs)]
		pub _0: bool,
	}
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
	const _: () = {
		use alloy::sol_types as alloy_sol_types;
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (
				alloy::sol_types::sol_data::Address,
				alloy::sol_types::sol_data::Address,
				alloy::sol_types::sol_data::Uint<256>,
			);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = (
				alloy::sol_types::private::Address,
				alloy::sol_types::private::Address,
				alloy::sol_types::private::primitives::aliases::U256,
			);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<transferFromCall> for UnderlyingRustTuple<'_> {
				fn from(value: transferFromCall) -> Self {
					(value.from, value.to, value.amount)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferFromCall {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self { from: tuple.0, to: tuple.1, amount: tuple.2 }
				}
			}
		}
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = (bool,);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<transferFromReturn> for UnderlyingRustTuple<'_> {
				fn from(value: transferFromReturn) -> Self {
					(value._0,)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferFromReturn {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self { _0: tuple.0 }
				}
			}
		}
		#[automatically_derived]
		impl alloy_sol_types::SolCall for transferFromCall {
			type Parameters<'a> = (
				alloy::sol_types::sol_data::Address,
				alloy::sol_types::sol_data::Address,
				alloy::sol_types::sol_data::Uint<256>,
			);
			type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
			type Return = bool;
			type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
			type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
			const SIGNATURE: &'static str = "transferFrom(address,address,uint256)";
			const SELECTOR: [u8; 4] = [35u8, 184u8, 114u8, 221u8];
			#[inline]
			fn new<'a>(tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType) -> Self {
				tuple.into()
			}
			#[inline]
			fn tokenize(&self) -> Self::Token<'_> {
				(
					<alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(&self.from),
					<alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(&self.to),
					<alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(&self.amount),
				)
			}
			#[inline]
			fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
				(<alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(ret),)
			}
			#[inline]
			fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(data).map(|r| {
					let r: transferFromReturn = r.into();
					r._0
				})
			}
			#[inline]
			fn abi_decode_returns_validate(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence_validate(data).map(|r| {
					let r: transferFromReturn = r.into();
					r._0
				})
			}
		}
	};
	///Container for all the [`MockERC20`](self) function calls.
	#[derive(Clone, serde::Serialize, serde::Deserialize)]
	pub enum MockERC20Calls {
		#[allow(missing_docs)]
		DOMAIN_SEPARATOR(DOMAIN_SEPARATORCall),
		#[allow(missing_docs)]
		allowance(allowanceCall),
		#[allow(missing_docs)]
		approve(approveCall),
		#[allow(missing_docs)]
		balanceOf(balanceOfCall),
		#[allow(missing_docs)]
		decimals(decimalsCall),
		#[allow(missing_docs)]
		initialize(initializeCall),
		#[allow(missing_docs)]
		name(nameCall),
		#[allow(missing_docs)]
		nonces(noncesCall),
		#[allow(missing_docs)]
		permit(permitCall),
		#[allow(missing_docs)]
		symbol(symbolCall),
		#[allow(missing_docs)]
		totalSupply(totalSupplyCall),
		#[allow(missing_docs)]
		transfer(transferCall),
		#[allow(missing_docs)]
		transferFrom(transferFromCall),
	}
	impl MockERC20Calls {
		/// All the selectors of this enum.
		///
		/// Note that the selectors might not be in the same order as the variants.
		/// No guarantees are made about the order of the selectors.
		///
		/// Prefer using `SolInterface` methods instead.
		pub const SELECTORS: &'static [[u8; 4usize]] = &[
			[6u8, 253u8, 222u8, 3u8],
			[9u8, 94u8, 167u8, 179u8],
			[22u8, 36u8, 246u8, 198u8],
			[24u8, 22u8, 13u8, 221u8],
			[35u8, 184u8, 114u8, 221u8],
			[49u8, 60u8, 229u8, 103u8],
			[54u8, 68u8, 229u8, 21u8],
			[112u8, 160u8, 130u8, 49u8],
			[126u8, 206u8, 190u8, 0u8],
			[149u8, 216u8, 155u8, 65u8],
			[169u8, 5u8, 156u8, 187u8],
			[213u8, 5u8, 172u8, 207u8],
			[221u8, 98u8, 237u8, 62u8],
		];
		/// The names of the variants in the same order as `SELECTORS`.
		pub const VARIANT_NAMES: &'static [&'static str] = &[
			::core::stringify!(name),
			::core::stringify!(approve),
			::core::stringify!(initialize),
			::core::stringify!(totalSupply),
			::core::stringify!(transferFrom),
			::core::stringify!(decimals),
			::core::stringify!(DOMAIN_SEPARATOR),
			::core::stringify!(balanceOf),
			::core::stringify!(nonces),
			::core::stringify!(symbol),
			::core::stringify!(transfer),
			::core::stringify!(permit),
			::core::stringify!(allowance),
		];
		/// The signatures in the same order as `SELECTORS`.
		pub const SIGNATURES: &'static [&'static str] = &[
			<nameCall as alloy_sol_types::SolCall>::SIGNATURE,
			<approveCall as alloy_sol_types::SolCall>::SIGNATURE,
			<initializeCall as alloy_sol_types::SolCall>::SIGNATURE,
			<totalSupplyCall as alloy_sol_types::SolCall>::SIGNATURE,
			<transferFromCall as alloy_sol_types::SolCall>::SIGNATURE,
			<decimalsCall as alloy_sol_types::SolCall>::SIGNATURE,
			<DOMAIN_SEPARATORCall as alloy_sol_types::SolCall>::SIGNATURE,
			<balanceOfCall as alloy_sol_types::SolCall>::SIGNATURE,
			<noncesCall as alloy_sol_types::SolCall>::SIGNATURE,
			<symbolCall as alloy_sol_types::SolCall>::SIGNATURE,
			<transferCall as alloy_sol_types::SolCall>::SIGNATURE,
			<permitCall as alloy_sol_types::SolCall>::SIGNATURE,
			<allowanceCall as alloy_sol_types::SolCall>::SIGNATURE,
		];
		/// Returns the signature for the given selector, if known.
		#[inline]
		pub fn signature_by_selector(selector: [u8; 4usize]) -> ::core::option::Option<&'static str> {
			match Self::SELECTORS.binary_search(&selector) {
				::core::result::Result::Ok(idx) => ::core::option::Option::Some(Self::SIGNATURES[idx]),
				::core::result::Result::Err(_) => ::core::option::Option::None,
			}
		}
		/// Returns the enum variant name for the given selector, if known.
		#[inline]
		pub fn name_by_selector(selector: [u8; 4usize]) -> ::core::option::Option<&'static str> {
			let sig = Self::signature_by_selector(selector)?;
			sig.split_once('(').map(|(name, _)| name)
		}
	}
	#[automatically_derived]
	impl alloy_sol_types::SolInterface for MockERC20Calls {
		const NAME: &'static str = "MockERC20Calls";
		const MIN_DATA_LENGTH: usize = 0usize;
		const COUNT: usize = 13usize;
		#[inline]
		fn selector(&self) -> [u8; 4] {
			match self {
				Self::DOMAIN_SEPARATOR(_) => <DOMAIN_SEPARATORCall as alloy_sol_types::SolCall>::SELECTOR,
				Self::allowance(_) => <allowanceCall as alloy_sol_types::SolCall>::SELECTOR,
				Self::approve(_) => <approveCall as alloy_sol_types::SolCall>::SELECTOR,
				Self::balanceOf(_) => <balanceOfCall as alloy_sol_types::SolCall>::SELECTOR,
				Self::decimals(_) => <decimalsCall as alloy_sol_types::SolCall>::SELECTOR,
				Self::initialize(_) => <initializeCall as alloy_sol_types::SolCall>::SELECTOR,
				Self::name(_) => <nameCall as alloy_sol_types::SolCall>::SELECTOR,
				Self::nonces(_) => <noncesCall as alloy_sol_types::SolCall>::SELECTOR,
				Self::permit(_) => <permitCall as alloy_sol_types::SolCall>::SELECTOR,
				Self::symbol(_) => <symbolCall as alloy_sol_types::SolCall>::SELECTOR,
				Self::totalSupply(_) => <totalSupplyCall as alloy_sol_types::SolCall>::SELECTOR,
				Self::transfer(_) => <transferCall as alloy_sol_types::SolCall>::SELECTOR,
				Self::transferFrom(_) => <transferFromCall as alloy_sol_types::SolCall>::SELECTOR,
			}
		}
		#[inline]
		fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
			Self::SELECTORS.get(i).copied()
		}
		#[inline]
		fn valid_selector(selector: [u8; 4]) -> bool {
			Self::SELECTORS.binary_search(&selector).is_ok()
		}
		#[inline]
		#[allow(non_snake_case)]
		fn abi_decode_raw(selector: [u8; 4], data: &[u8]) -> alloy_sol_types::Result<Self> {
			static DECODE_SHIMS: &[fn(&[u8]) -> alloy_sol_types::Result<MockERC20Calls>] = &[
				{
					fn name(data: &[u8]) -> alloy_sol_types::Result<MockERC20Calls> {
						<nameCall as alloy_sol_types::SolCall>::abi_decode_raw(data).map(MockERC20Calls::name)
					}
					name
				},
				{
					fn approve(data: &[u8]) -> alloy_sol_types::Result<MockERC20Calls> {
						<approveCall as alloy_sol_types::SolCall>::abi_decode_raw(data).map(MockERC20Calls::approve)
					}
					approve
				},
				{
					fn initialize(data: &[u8]) -> alloy_sol_types::Result<MockERC20Calls> {
						<initializeCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
							.map(MockERC20Calls::initialize)
					}
					initialize
				},
				{
					fn totalSupply(data: &[u8]) -> alloy_sol_types::Result<MockERC20Calls> {
						<totalSupplyCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
							.map(MockERC20Calls::totalSupply)
					}
					totalSupply
				},
				{
					fn transferFrom(data: &[u8]) -> alloy_sol_types::Result<MockERC20Calls> {
						<transferFromCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
							.map(MockERC20Calls::transferFrom)
					}
					transferFrom
				},
				{
					fn decimals(data: &[u8]) -> alloy_sol_types::Result<MockERC20Calls> {
						<decimalsCall as alloy_sol_types::SolCall>::abi_decode_raw(data).map(MockERC20Calls::decimals)
					}
					decimals
				},
				{
					fn DOMAIN_SEPARATOR(data: &[u8]) -> alloy_sol_types::Result<MockERC20Calls> {
						<DOMAIN_SEPARATORCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
							.map(MockERC20Calls::DOMAIN_SEPARATOR)
					}
					DOMAIN_SEPARATOR
				},
				{
					fn balanceOf(data: &[u8]) -> alloy_sol_types::Result<MockERC20Calls> {
						<balanceOfCall as alloy_sol_types::SolCall>::abi_decode_raw(data).map(MockERC20Calls::balanceOf)
					}
					balanceOf
				},
				{
					fn nonces(data: &[u8]) -> alloy_sol_types::Result<MockERC20Calls> {
						<noncesCall as alloy_sol_types::SolCall>::abi_decode_raw(data).map(MockERC20Calls::nonces)
					}
					nonces
				},
				{
					fn symbol(data: &[u8]) -> alloy_sol_types::Result<MockERC20Calls> {
						<symbolCall as alloy_sol_types::SolCall>::abi_decode_raw(data).map(MockERC20Calls::symbol)
					}
					symbol
				},
				{
					fn transfer(data: &[u8]) -> alloy_sol_types::Result<MockERC20Calls> {
						<transferCall as alloy_sol_types::SolCall>::abi_decode_raw(data).map(MockERC20Calls::transfer)
					}
					transfer
				},
				{
					fn permit(data: &[u8]) -> alloy_sol_types::Result<MockERC20Calls> {
						<permitCall as alloy_sol_types::SolCall>::abi_decode_raw(data).map(MockERC20Calls::permit)
					}
					permit
				},
				{
					fn allowance(data: &[u8]) -> alloy_sol_types::Result<MockERC20Calls> {
						<allowanceCall as alloy_sol_types::SolCall>::abi_decode_raw(data).map(MockERC20Calls::allowance)
					}
					allowance
				},
			];
			let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
				return Err(alloy_sol_types::Error::unknown_selector(
					<Self as alloy_sol_types::SolInterface>::NAME,
					selector,
				));
			};
			DECODE_SHIMS[idx](data)
		}
		#[inline]
		#[allow(non_snake_case)]
		fn abi_decode_raw_validate(selector: [u8; 4], data: &[u8]) -> alloy_sol_types::Result<Self> {
			static DECODE_VALIDATE_SHIMS: &[fn(&[u8]) -> alloy_sol_types::Result<MockERC20Calls>] = &[
				{
					fn name(data: &[u8]) -> alloy_sol_types::Result<MockERC20Calls> {
						<nameCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(data).map(MockERC20Calls::name)
					}
					name
				},
				{
					fn approve(data: &[u8]) -> alloy_sol_types::Result<MockERC20Calls> {
						<approveCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(data)
							.map(MockERC20Calls::approve)
					}
					approve
				},
				{
					fn initialize(data: &[u8]) -> alloy_sol_types::Result<MockERC20Calls> {
						<initializeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(data)
							.map(MockERC20Calls::initialize)
					}
					initialize
				},
				{
					fn totalSupply(data: &[u8]) -> alloy_sol_types::Result<MockERC20Calls> {
						<totalSupplyCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(data)
							.map(MockERC20Calls::totalSupply)
					}
					totalSupply
				},
				{
					fn transferFrom(data: &[u8]) -> alloy_sol_types::Result<MockERC20Calls> {
						<transferFromCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(data)
							.map(MockERC20Calls::transferFrom)
					}
					transferFrom
				},
				{
					fn decimals(data: &[u8]) -> alloy_sol_types::Result<MockERC20Calls> {
						<decimalsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(data)
							.map(MockERC20Calls::decimals)
					}
					decimals
				},
				{
					fn DOMAIN_SEPARATOR(data: &[u8]) -> alloy_sol_types::Result<MockERC20Calls> {
						<DOMAIN_SEPARATORCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(data)
							.map(MockERC20Calls::DOMAIN_SEPARATOR)
					}
					DOMAIN_SEPARATOR
				},
				{
					fn balanceOf(data: &[u8]) -> alloy_sol_types::Result<MockERC20Calls> {
						<balanceOfCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(data)
							.map(MockERC20Calls::balanceOf)
					}
					balanceOf
				},
				{
					fn nonces(data: &[u8]) -> alloy_sol_types::Result<MockERC20Calls> {
						<noncesCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(data)
							.map(MockERC20Calls::nonces)
					}
					nonces
				},
				{
					fn symbol(data: &[u8]) -> alloy_sol_types::Result<MockERC20Calls> {
						<symbolCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(data)
							.map(MockERC20Calls::symbol)
					}
					symbol
				},
				{
					fn transfer(data: &[u8]) -> alloy_sol_types::Result<MockERC20Calls> {
						<transferCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(data)
							.map(MockERC20Calls::transfer)
					}
					transfer
				},
				{
					fn permit(data: &[u8]) -> alloy_sol_types::Result<MockERC20Calls> {
						<permitCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(data)
							.map(MockERC20Calls::permit)
					}
					permit
				},
				{
					fn allowance(data: &[u8]) -> alloy_sol_types::Result<MockERC20Calls> {
						<allowanceCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(data)
							.map(MockERC20Calls::allowance)
					}
					allowance
				},
			];
			let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
				return Err(alloy_sol_types::Error::unknown_selector(
					<Self as alloy_sol_types::SolInterface>::NAME,
					selector,
				));
			};
			DECODE_VALIDATE_SHIMS[idx](data)
		}
		#[inline]
		fn abi_encoded_size(&self) -> usize {
			match self {
				Self::DOMAIN_SEPARATOR(inner) => {
					<DOMAIN_SEPARATORCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
				}
				Self::allowance(inner) => <allowanceCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
				Self::approve(inner) => <approveCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
				Self::balanceOf(inner) => <balanceOfCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
				Self::decimals(inner) => <decimalsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
				Self::initialize(inner) => <initializeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
				Self::name(inner) => <nameCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
				Self::nonces(inner) => <noncesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
				Self::permit(inner) => <permitCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
				Self::symbol(inner) => <symbolCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
				Self::totalSupply(inner) => <totalSupplyCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
				Self::transfer(inner) => <transferCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
				Self::transferFrom(inner) => <transferFromCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
			}
		}
		#[inline]
		fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
			match self {
				Self::DOMAIN_SEPARATOR(inner) => {
					<DOMAIN_SEPARATORCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
				}
				Self::allowance(inner) => <allowanceCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
				Self::approve(inner) => <approveCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
				Self::balanceOf(inner) => <balanceOfCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
				Self::decimals(inner) => <decimalsCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
				Self::initialize(inner) => <initializeCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
				Self::name(inner) => <nameCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
				Self::nonces(inner) => <noncesCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
				Self::permit(inner) => <permitCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
				Self::symbol(inner) => <symbolCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
				Self::totalSupply(inner) => <totalSupplyCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
				Self::transfer(inner) => <transferCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
				Self::transferFrom(inner) => <transferFromCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
			}
		}
	}
	///Container for all the [`MockERC20`](self) events.
	#[derive(Clone, serde::Serialize, serde::Deserialize, Debug, PartialEq, Eq, Hash)]
	pub enum MockERC20Events {
		#[allow(missing_docs)]
		Approval(Approval),
		#[allow(missing_docs)]
		Transfer(Transfer),
	}
	impl MockERC20Events {
		/// All the selectors of this enum.
		///
		/// Note that the selectors might not be in the same order as the variants.
		/// No guarantees are made about the order of the selectors.
		///
		/// Prefer using `SolInterface` methods instead.
		pub const SELECTORS: &'static [[u8; 32usize]] = &[
			[
				140u8, 91u8, 225u8, 229u8, 235u8, 236u8, 125u8, 91u8, 209u8, 79u8, 113u8, 66u8, 125u8, 30u8, 132u8,
				243u8, 221u8, 3u8, 20u8, 192u8, 247u8, 178u8, 41u8, 30u8, 91u8, 32u8, 10u8, 200u8, 199u8, 195u8, 185u8,
				37u8,
			],
			[
				221u8, 242u8, 82u8, 173u8, 27u8, 226u8, 200u8, 155u8, 105u8, 194u8, 176u8, 104u8, 252u8, 55u8, 141u8,
				170u8, 149u8, 43u8, 167u8, 241u8, 99u8, 196u8, 161u8, 22u8, 40u8, 245u8, 90u8, 77u8, 245u8, 35u8,
				179u8, 239u8,
			],
		];
		/// The names of the variants in the same order as `SELECTORS`.
		pub const VARIANT_NAMES: &'static [&'static str] =
			&[::core::stringify!(Approval), ::core::stringify!(Transfer)];
		/// The signatures in the same order as `SELECTORS`.
		pub const SIGNATURES: &'static [&'static str] =
			&[<Approval as alloy_sol_types::SolEvent>::SIGNATURE, <Transfer as alloy_sol_types::SolEvent>::SIGNATURE];
		/// Returns the signature for the given selector, if known.
		#[inline]
		pub fn signature_by_selector(selector: [u8; 32usize]) -> ::core::option::Option<&'static str> {
			match Self::SELECTORS.binary_search(&selector) {
				::core::result::Result::Ok(idx) => ::core::option::Option::Some(Self::SIGNATURES[idx]),
				::core::result::Result::Err(_) => ::core::option::Option::None,
			}
		}
		/// Returns the enum variant name for the given selector, if known.
		#[inline]
		pub fn name_by_selector(selector: [u8; 32usize]) -> ::core::option::Option<&'static str> {
			let sig = Self::signature_by_selector(selector)?;
			sig.split_once('(').map(|(name, _)| name)
		}
	}
	#[automatically_derived]
	impl alloy_sol_types::SolEventInterface for MockERC20Events {
		const NAME: &'static str = "MockERC20Events";
		const COUNT: usize = 2usize;
		fn decode_raw_log(topics: &[alloy_sol_types::Word], data: &[u8]) -> alloy_sol_types::Result<Self> {
			match topics.first().copied() {
				Some(<Approval as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
					<Approval as alloy_sol_types::SolEvent>::decode_raw_log(topics, data).map(Self::Approval)
				}
				Some(<Transfer as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
					<Transfer as alloy_sol_types::SolEvent>::decode_raw_log(topics, data).map(Self::Transfer)
				}
				_ => alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
					name: <Self as alloy_sol_types::SolEventInterface>::NAME,
					log: alloy_sol_types::private::Box::new(alloy_sol_types::private::LogData::new_unchecked(
						topics.to_vec(),
						data.to_vec().into(),
					)),
				}),
			}
		}
	}
	#[automatically_derived]
	impl alloy_sol_types::private::IntoLogData for MockERC20Events {
		fn to_log_data(&self) -> alloy_sol_types::private::LogData {
			match self {
				Self::Approval(inner) => alloy_sol_types::private::IntoLogData::to_log_data(inner),
				Self::Transfer(inner) => alloy_sol_types::private::IntoLogData::to_log_data(inner),
			}
		}
		fn into_log_data(self) -> alloy_sol_types::private::LogData {
			match self {
				Self::Approval(inner) => alloy_sol_types::private::IntoLogData::into_log_data(inner),
				Self::Transfer(inner) => alloy_sol_types::private::IntoLogData::into_log_data(inner),
			}
		}
	}
	use alloy::contract as alloy_contract;
	/**Creates a new wrapper around an on-chain [`MockERC20`](self) contract instance.

	See the [wrapper's documentation](`MockERC20Instance`) for more details.*/
	#[inline]
	pub const fn new<P: alloy_contract::private::Provider<N>, N: alloy_contract::private::Network>(
		address: alloy_sol_types::private::Address,
		__provider: P,
	) -> MockERC20Instance<P, N> {
		MockERC20Instance::<P, N>::new(address, __provider)
	}
	/**Deploys this contract using the given `provider` and constructor arguments, if any.

	Returns a new instance of the contract, if the deployment was successful.

	For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
	#[inline]
	pub fn deploy<P: alloy_contract::private::Provider<N>, N: alloy_contract::private::Network>(
		__provider: P,
	) -> impl ::core::future::Future<Output = alloy_contract::Result<MockERC20Instance<P, N>>> {
		MockERC20Instance::<P, N>::deploy(__provider)
	}
	/**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
	and constructor arguments, if any.

	This is a simple wrapper around creating a `RawCallBuilder` with the data set to
	the bytecode concatenated with the constructor's ABI-encoded arguments.*/
	#[inline]
	pub fn deploy_builder<P: alloy_contract::private::Provider<N>, N: alloy_contract::private::Network>(
		__provider: P,
	) -> alloy_contract::RawCallBuilder<P, N> {
		MockERC20Instance::<P, N>::deploy_builder(__provider)
	}
	/**A [`MockERC20`](self) instance.

	Contains type-safe methods for interacting with an on-chain instance of the
	[`MockERC20`](self) contract located at a given `address`, using a given
	provider `P`.

	If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
	documentation on how to provide it), the `deploy` and `deploy_builder` methods can
	be used to deploy a new instance of the contract.

	See the [module-level documentation](self) for all the available methods.*/
	#[derive(Clone)]
	pub struct MockERC20Instance<P, N = alloy_contract::private::Ethereum> {
		address: alloy_sol_types::private::Address,
		provider: P,
		_network: ::core::marker::PhantomData<N>,
	}
	#[automatically_derived]
	impl<P, N> ::core::fmt::Debug for MockERC20Instance<P, N> {
		#[inline]
		fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
			f.debug_tuple("MockERC20Instance").field(&self.address).finish()
		}
	}
	/// Instantiation and getters/setters.
	impl<P: alloy_contract::private::Provider<N>, N: alloy_contract::private::Network> MockERC20Instance<P, N> {
		/**Creates a new wrapper around an on-chain [`MockERC20`](self) contract instance.

		See the [wrapper's documentation](`MockERC20Instance`) for more details.*/
		#[inline]
		pub const fn new(address: alloy_sol_types::private::Address, __provider: P) -> Self {
			Self { address, provider: __provider, _network: ::core::marker::PhantomData }
		}
		/**Deploys this contract using the given `provider` and constructor arguments, if any.

		Returns a new instance of the contract, if the deployment was successful.

		For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
		#[inline]
		pub async fn deploy(__provider: P) -> alloy_contract::Result<MockERC20Instance<P, N>> {
			let call_builder = Self::deploy_builder(__provider);
			let contract_address = call_builder.deploy().await?;
			Ok(Self::new(contract_address, call_builder.provider))
		}
		/**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
		and constructor arguments, if any.

		This is a simple wrapper around creating a `RawCallBuilder` with the data set to
		the bytecode concatenated with the constructor's ABI-encoded arguments.*/
		#[inline]
		pub fn deploy_builder(__provider: P) -> alloy_contract::RawCallBuilder<P, N> {
			alloy_contract::RawCallBuilder::new_raw_deploy(__provider, ::core::clone::Clone::clone(&BYTECODE))
		}
		/// Returns a reference to the address.
		#[inline]
		pub const fn address(&self) -> &alloy_sol_types::private::Address {
			&self.address
		}
		/// Sets the address.
		#[inline]
		pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
			self.address = address;
		}
		/// Sets the address and returns `self`.
		pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
			self.set_address(address);
			self
		}
		/// Returns a reference to the provider.
		#[inline]
		pub const fn provider(&self) -> &P {
			&self.provider
		}
	}
	impl<P: ::core::clone::Clone, N> MockERC20Instance<&P, N> {
		/// Clones the provider and returns a new instance with the cloned provider.
		#[inline]
		pub fn with_cloned_provider(self) -> MockERC20Instance<P, N> {
			MockERC20Instance {
				address: self.address,
				provider: ::core::clone::Clone::clone(&self.provider),
				_network: ::core::marker::PhantomData,
			}
		}
	}
	/// Function calls.
	impl<P: alloy_contract::private::Provider<N>, N: alloy_contract::private::Network> MockERC20Instance<P, N> {
		/// Creates a new call builder using this contract instance's provider and address.
		///
		/// Note that the call can be any function call, not just those defined in this
		/// contract. Prefer using the other methods for building type-safe contract calls.
		pub fn call_builder<C: alloy_sol_types::SolCall>(&self, call: &C) -> alloy_contract::SolCallBuilder<&P, C, N> {
			alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
		}
		///Creates a new call builder for the [`DOMAIN_SEPARATOR`] function.
		pub fn DOMAIN_SEPARATOR(&self) -> alloy_contract::SolCallBuilder<&P, DOMAIN_SEPARATORCall, N> {
			self.call_builder(&DOMAIN_SEPARATORCall)
		}
		///Creates a new call builder for the [`allowance`] function.
		pub fn allowance(
			&self,
			owner: alloy::sol_types::private::Address,
			spender: alloy::sol_types::private::Address,
		) -> alloy_contract::SolCallBuilder<&P, allowanceCall, N> {
			self.call_builder(&allowanceCall { owner, spender })
		}
		///Creates a new call builder for the [`approve`] function.
		pub fn approve(
			&self,
			spender: alloy::sol_types::private::Address,
			amount: alloy::sol_types::private::primitives::aliases::U256,
		) -> alloy_contract::SolCallBuilder<&P, approveCall, N> {
			self.call_builder(&approveCall { spender, amount })
		}
		///Creates a new call builder for the [`balanceOf`] function.
		pub fn balanceOf(
			&self,
			owner: alloy::sol_types::private::Address,
		) -> alloy_contract::SolCallBuilder<&P, balanceOfCall, N> {
			self.call_builder(&balanceOfCall { owner })
		}
		///Creates a new call builder for the [`decimals`] function.
		pub fn decimals(&self) -> alloy_contract::SolCallBuilder<&P, decimalsCall, N> {
			self.call_builder(&decimalsCall)
		}
		///Creates a new call builder for the [`initialize`] function.
		pub fn initialize(
			&self,
			name_: alloy::sol_types::private::String,
			symbol_: alloy::sol_types::private::String,
			decimals_: u8,
		) -> alloy_contract::SolCallBuilder<&P, initializeCall, N> {
			self.call_builder(&initializeCall { name_, symbol_, decimals_ })
		}
		///Creates a new call builder for the [`name`] function.
		pub fn name(&self) -> alloy_contract::SolCallBuilder<&P, nameCall, N> {
			self.call_builder(&nameCall)
		}
		///Creates a new call builder for the [`nonces`] function.
		pub fn nonces(
			&self,
			_0: alloy::sol_types::private::Address,
		) -> alloy_contract::SolCallBuilder<&P, noncesCall, N> {
			self.call_builder(&noncesCall(_0))
		}
		///Creates a new call builder for the [`permit`] function.
		pub fn permit(
			&self,
			owner: alloy::sol_types::private::Address,
			spender: alloy::sol_types::private::Address,
			value: alloy::sol_types::private::primitives::aliases::U256,
			deadline: alloy::sol_types::private::primitives::aliases::U256,
			v: u8,
			r: alloy::sol_types::private::FixedBytes<32>,
			s: alloy::sol_types::private::FixedBytes<32>,
		) -> alloy_contract::SolCallBuilder<&P, permitCall, N> {
			self.call_builder(&permitCall { owner, spender, value, deadline, v, r, s })
		}
		///Creates a new call builder for the [`symbol`] function.
		pub fn symbol(&self) -> alloy_contract::SolCallBuilder<&P, symbolCall, N> {
			self.call_builder(&symbolCall)
		}
		///Creates a new call builder for the [`totalSupply`] function.
		pub fn totalSupply(&self) -> alloy_contract::SolCallBuilder<&P, totalSupplyCall, N> {
			self.call_builder(&totalSupplyCall)
		}
		///Creates a new call builder for the [`transfer`] function.
		pub fn transfer(
			&self,
			to: alloy::sol_types::private::Address,
			amount: alloy::sol_types::private::primitives::aliases::U256,
		) -> alloy_contract::SolCallBuilder<&P, transferCall, N> {
			self.call_builder(&transferCall { to, amount })
		}
		///Creates a new call builder for the [`transferFrom`] function.
		pub fn transferFrom(
			&self,
			from: alloy::sol_types::private::Address,
			to: alloy::sol_types::private::Address,
			amount: alloy::sol_types::private::primitives::aliases::U256,
		) -> alloy_contract::SolCallBuilder<&P, transferFromCall, N> {
			self.call_builder(&transferFromCall { from, to, amount })
		}
	}
	/// Event filters.
	impl<P: alloy_contract::private::Provider<N>, N: alloy_contract::private::Network> MockERC20Instance<P, N> {
		/// Creates a new event filter using this contract instance's provider and address.
		///
		/// Note that the type can be any event, not just those defined in this contract.
		/// Prefer using the other methods for building type-safe event filters.
		pub fn event_filter<E: alloy_sol_types::SolEvent>(&self) -> alloy_contract::Event<&P, E, N> {
			alloy_contract::Event::new_sol(&self.provider, &self.address)
		}
		///Creates a new event filter for the [`Approval`] event.
		pub fn Approval_filter(&self) -> alloy_contract::Event<&P, Approval, N> {
			self.event_filter::<Approval>()
		}
		///Creates a new event filter for the [`Transfer`] event.
		pub fn Transfer_filter(&self) -> alloy_contract::Event<&P, Transfer, N> {
			self.event_filter::<Transfer>()
		}
	}
}
