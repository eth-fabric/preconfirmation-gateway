/**

Generated by the following Solidity interface...
```solidity
interface ECDSAUtils {
	function _toLittleEndian(uint64 x) external pure returns (bytes32);
	function recover(bytes32 messageHash, bytes memory signature, bytes32 signingDomain, bytes32 signingId, uint64 nonce, bytes32 chainId) external view returns (address);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
	"type": "function",
	"name": "_toLittleEndian",
	"inputs": [
	  {
		"name": "x",
		"type": "uint64",
		"internalType": "uint64"
	  }
	],
	"outputs": [
	  {
		"name": "",
		"type": "bytes32",
		"internalType": "bytes32"
	  }
	],
	"stateMutability": "pure"
  },
  {
	"type": "function",
	"name": "recover",
	"inputs": [
	  {
		"name": "messageHash",
		"type": "bytes32",
		"internalType": "bytes32"
	  },
	  {
		"name": "signature",
		"type": "bytes",
		"internalType": "bytes"
	  },
	  {
		"name": "signingDomain",
		"type": "bytes32",
		"internalType": "bytes32"
	  },
	  {
		"name": "signingId",
		"type": "bytes32",
		"internalType": "bytes32"
	  },
	  {
		"name": "nonce",
		"type": "uint64",
		"internalType": "uint64"
	  },
	  {
		"name": "chainId",
		"type": "bytes32",
		"internalType": "bytes32"
	  }
	],
	"outputs": [
	  {
		"name": "",
		"type": "address",
		"internalType": "address"
	  }
	],
	"stateMutability": "view"
  }
]
```*/
#[allow(
	non_camel_case_types,
	non_snake_case,
	clippy::pub_underscore_fields,
	clippy::style,
	clippy::empty_structs_with_brackets
)]
pub mod ECDSAUtils {
	use super::*;
	use alloy::sol_types as alloy_sol_types;
	/// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x610592610034600b8282823980515f1a607314602857634e487b7160e01b5f525f60045260245ffd5b305f52607381538281f3fe730000000000000000000000000000000000000000301460806040526004361061003f575f3560e01c80635eea787d14610043578063c859272c14610069575b5f80fd5b6100566100513660046103c0565b610094565b6040519081526020015b60405180910390f35b61007c6100773660046103ed565b61011e565b6040516001600160a01b039091168152602001610060565b6040805160088082528183019092525f918291906020820181803683370190505090505f5b600881101561010d576100cd8160086104cc565b8467ffffffffffffffff16901c60f81b8282815181106100ef576100ef6104f5565b60200101906001600160f81b03191690815f1a9053506001016100b9565b5061011781610509565b9392505050565b5f8061012d8887878787610145565b90506101398188610318565b98975050505050505050565b5f806002808887604051602001610166929190918252602082015260400190565b60408051601f19818403018152908290526101809161052f565b602060405180830381855afa15801561019b573d5f803e3d5ffd5b5050506040513d601f19601f820116820180604052508101906101be9190610545565b60026101c987610094565b604080516020810192909252810187905260600160408051601f19818403018152908290526101f79161052f565b602060405180830381855afa158015610212573d5f803e3d5ffd5b5050506040513d601f19601f820116820180604052508101906102359190610545565b60408051602081019390935282015260600160408051601f19818403018152908290526102619161052f565b602060405180830381855afa15801561027c573d5f803e3d5ffd5b5050506040513d601f19601f8201168201806040525081019061029f9190610545565b90505f600282886040516020016102c0929190918252602082015260400190565b60408051601f19818403018152908290526102da9161052f565b602060405180830381855afa1580156102f5573d5f803e3d5ffd5b5050506040513d601f19601f820116820180604052508101906101399190610545565b5f60405182516040811461033457604181146103555750610390565b604084015160ff81901c601b016020526001600160ff1b0316606052610368565b60608401515f1a60205260408401516060525b50835f5260208301516040526020600160805f60015afa5191505f606052806040523d61039d575b638baa579f5f526004601cfd5b5092915050565b803567ffffffffffffffff811681146103bb575f80fd5b919050565b5f602082840312156103d0575f80fd5b610117826103a4565b634e487b7160e01b5f52604160045260245ffd5b5f805f805f8060c08789031215610402575f80fd5b86359550602087013567ffffffffffffffff80821115610420575f80fd5b818901915089601f830112610433575f80fd5b813581811115610445576104456103d9565b604051601f8201601f19908116603f0116810190838211818310171561046d5761046d6103d9565b816040528281528c6020848701011115610485575f80fd5b826020860160208301375f60208483010152809950505050505060408701359350606087013592506104b9608088016103a4565b915060a087013590509295509295509295565b80820281158282048414176104ef57634e487b7160e01b5f52601160045260245ffd5b92915050565b634e487b7160e01b5f52603260045260245ffd5b80516020808301519190811015610529575f198160200360031b1b821691505b50919050565b5f82518060208501845e5f920191825250919050565b5f60208284031215610555575f80fd5b505191905056fea2646970667358221220c4af44fe181eb32a34fb04b057e252d8901c153af503cca29b74f55877f4441e64736f6c63430008190033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"a\x05\x92a\x004`\x0B\x82\x82\x829\x80Q_\x1A`s\x14`(WcNH{q`\xE0\x1B_R_`\x04R`$_\xFD[0_R`s\x81S\x82\x81\xF3\xFEs\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x000\x14`\x80`@R`\x046\x10a\0?W_5`\xE0\x1C\x80c^\xEAx}\x14a\0CW\x80c\xC8Y',\x14a\0iW[_\x80\xFD[a\0Va\0Q6`\x04a\x03\xC0V[a\0\x94V[`@Q\x90\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\0|a\0w6`\x04a\x03\xEDV[a\x01\x1EV[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\0`V[`@\x80Q`\x08\x80\x82R\x81\x83\x01\x90\x92R_\x91\x82\x91\x90` \x82\x01\x81\x806\x837\x01\x90PP\x90P_[`\x08\x81\x10\x15a\x01\rWa\0\xCD\x81`\x08a\x04\xCCV[\x84g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x1C`\xF8\x1B\x82\x82\x81Q\x81\x10a\0\xEFWa\0\xEFa\x04\xF5V[` \x01\x01\x90`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x81_\x1A\x90SP`\x01\x01a\0\xB9V[Pa\x01\x17\x81a\x05\tV[\x93\x92PPPV[_\x80a\x01-\x88\x87\x87\x87\x87a\x01EV[\x90Pa\x019\x81\x88a\x03\x18V[\x98\x97PPPPPPPPV[_\x80`\x02\x80\x88\x87`@Q` \x01a\x01f\x92\x91\x90\x91\x82R` \x82\x01R`@\x01\x90V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90Ra\x01\x80\x91a\x05/V[` `@Q\x80\x83\x03\x81\x85Z\xFA\x15\x80\x15a\x01\x9BW=_\x80>=_\xFD[PPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x01\xBE\x91\x90a\x05EV[`\x02a\x01\xC9\x87a\0\x94V[`@\x80Q` \x81\x01\x92\x90\x92R\x81\x01\x87\x90R``\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90Ra\x01\xF7\x91a\x05/V[` `@Q\x80\x83\x03\x81\x85Z\xFA\x15\x80\x15a\x02\x12W=_\x80>=_\xFD[PPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x025\x91\x90a\x05EV[`@\x80Q` \x81\x01\x93\x90\x93R\x82\x01R``\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90Ra\x02a\x91a\x05/V[` `@Q\x80\x83\x03\x81\x85Z\xFA\x15\x80\x15a\x02|W=_\x80>=_\xFD[PPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x02\x9F\x91\x90a\x05EV[\x90P_`\x02\x82\x88`@Q` \x01a\x02\xC0\x92\x91\x90\x91\x82R` \x82\x01R`@\x01\x90V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90Ra\x02\xDA\x91a\x05/V[` `@Q\x80\x83\x03\x81\x85Z\xFA\x15\x80\x15a\x02\xF5W=_\x80>=_\xFD[PPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x019\x91\x90a\x05EV[_`@Q\x82Q`@\x81\x14a\x034W`A\x81\x14a\x03UWPa\x03\x90V[`@\x84\x01Q`\xFF\x81\x90\x1C`\x1B\x01` R`\x01`\x01`\xFF\x1B\x03\x16``Ra\x03hV[``\x84\x01Q_\x1A` R`@\x84\x01Q``R[P\x83_R` \x83\x01Q`@R` `\x01`\x80_`\x01Z\xFAQ\x91P_``R\x80`@R=a\x03\x9DW[c\x8B\xAAW\x9F_R`\x04`\x1C\xFD[P\x92\x91PPV[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x14a\x03\xBBW_\x80\xFD[\x91\x90PV[_` \x82\x84\x03\x12\x15a\x03\xD0W_\x80\xFD[a\x01\x17\x82a\x03\xA4V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[_\x80_\x80_\x80`\xC0\x87\x89\x03\x12\x15a\x04\x02W_\x80\xFD[\x865\x95P` \x87\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15a\x04 W_\x80\xFD[\x81\x89\x01\x91P\x89`\x1F\x83\x01\x12a\x043W_\x80\xFD[\x815\x81\x81\x11\x15a\x04EWa\x04Ea\x03\xD9V[`@Q`\x1F\x82\x01`\x1F\x19\x90\x81\x16`?\x01\x16\x81\x01\x90\x83\x82\x11\x81\x83\x10\x17\x15a\x04mWa\x04ma\x03\xD9V[\x81`@R\x82\x81R\x8C` \x84\x87\x01\x01\x11\x15a\x04\x85W_\x80\xFD[\x82` \x86\x01` \x83\x017_` \x84\x83\x01\x01R\x80\x99PPPPPP`@\x87\x015\x93P``\x87\x015\x92Pa\x04\xB9`\x80\x88\x01a\x03\xA4V[\x91P`\xA0\x87\x015\x90P\x92\x95P\x92\x95P\x92\x95V[\x80\x82\x02\x81\x15\x82\x82\x04\x84\x14\x17a\x04\xEFWcNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[\x92\x91PPV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[\x80Q` \x80\x83\x01Q\x91\x90\x81\x10\x15a\x05)W_\x19\x81` \x03`\x03\x1B\x1B\x82\x16\x91P[P\x91\x90PV[_\x82Q\x80` \x85\x01\x84^_\x92\x01\x91\x82RP\x91\x90PV[_` \x82\x84\x03\x12\x15a\x05UW_\x80\xFD[PQ\x91\x90PV\xFE\xA2dipfsX\"\x12 \xC4\xAFD\xFE\x18\x1E\xB3*4\xFB\x04\xB0W\xE2R\xD8\x90\x1C\x15:\xF5\x03\xCC\xA2\x9Bt\xF5Xw\xF4D\x1EdsolcC\0\x08\x19\x003",
    );
	/// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x730000000000000000000000000000000000000000301460806040526004361061003f575f3560e01c80635eea787d14610043578063c859272c14610069575b5f80fd5b6100566100513660046103c0565b610094565b6040519081526020015b60405180910390f35b61007c6100773660046103ed565b61011e565b6040516001600160a01b039091168152602001610060565b6040805160088082528183019092525f918291906020820181803683370190505090505f5b600881101561010d576100cd8160086104cc565b8467ffffffffffffffff16901c60f81b8282815181106100ef576100ef6104f5565b60200101906001600160f81b03191690815f1a9053506001016100b9565b5061011781610509565b9392505050565b5f8061012d8887878787610145565b90506101398188610318565b98975050505050505050565b5f806002808887604051602001610166929190918252602082015260400190565b60408051601f19818403018152908290526101809161052f565b602060405180830381855afa15801561019b573d5f803e3d5ffd5b5050506040513d601f19601f820116820180604052508101906101be9190610545565b60026101c987610094565b604080516020810192909252810187905260600160408051601f19818403018152908290526101f79161052f565b602060405180830381855afa158015610212573d5f803e3d5ffd5b5050506040513d601f19601f820116820180604052508101906102359190610545565b60408051602081019390935282015260600160408051601f19818403018152908290526102619161052f565b602060405180830381855afa15801561027c573d5f803e3d5ffd5b5050506040513d601f19601f8201168201806040525081019061029f9190610545565b90505f600282886040516020016102c0929190918252602082015260400190565b60408051601f19818403018152908290526102da9161052f565b602060405180830381855afa1580156102f5573d5f803e3d5ffd5b5050506040513d601f19601f820116820180604052508101906101399190610545565b5f60405182516040811461033457604181146103555750610390565b604084015160ff81901c601b016020526001600160ff1b0316606052610368565b60608401515f1a60205260408401516060525b50835f5260208301516040526020600160805f60015afa5191505f606052806040523d61039d575b638baa579f5f526004601cfd5b5092915050565b803567ffffffffffffffff811681146103bb575f80fd5b919050565b5f602082840312156103d0575f80fd5b610117826103a4565b634e487b7160e01b5f52604160045260245ffd5b5f805f805f8060c08789031215610402575f80fd5b86359550602087013567ffffffffffffffff80821115610420575f80fd5b818901915089601f830112610433575f80fd5b813581811115610445576104456103d9565b604051601f8201601f19908116603f0116810190838211818310171561046d5761046d6103d9565b816040528281528c6020848701011115610485575f80fd5b826020860160208301375f60208483010152809950505050505060408701359350606087013592506104b9608088016103a4565b915060a087013590509295509295509295565b80820281158282048414176104ef57634e487b7160e01b5f52601160045260245ffd5b92915050565b634e487b7160e01b5f52603260045260245ffd5b80516020808301519190811015610529575f198160200360031b1b821691505b50919050565b5f82518060208501845e5f920191825250919050565b5f60208284031215610555575f80fd5b505191905056fea2646970667358221220c4af44fe181eb32a34fb04b057e252d8901c153af503cca29b74f55877f4441e64736f6c63430008190033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"s\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x000\x14`\x80`@R`\x046\x10a\0?W_5`\xE0\x1C\x80c^\xEAx}\x14a\0CW\x80c\xC8Y',\x14a\0iW[_\x80\xFD[a\0Va\0Q6`\x04a\x03\xC0V[a\0\x94V[`@Q\x90\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\0|a\0w6`\x04a\x03\xEDV[a\x01\x1EV[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\0`V[`@\x80Q`\x08\x80\x82R\x81\x83\x01\x90\x92R_\x91\x82\x91\x90` \x82\x01\x81\x806\x837\x01\x90PP\x90P_[`\x08\x81\x10\x15a\x01\rWa\0\xCD\x81`\x08a\x04\xCCV[\x84g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x1C`\xF8\x1B\x82\x82\x81Q\x81\x10a\0\xEFWa\0\xEFa\x04\xF5V[` \x01\x01\x90`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x81_\x1A\x90SP`\x01\x01a\0\xB9V[Pa\x01\x17\x81a\x05\tV[\x93\x92PPPV[_\x80a\x01-\x88\x87\x87\x87\x87a\x01EV[\x90Pa\x019\x81\x88a\x03\x18V[\x98\x97PPPPPPPPV[_\x80`\x02\x80\x88\x87`@Q` \x01a\x01f\x92\x91\x90\x91\x82R` \x82\x01R`@\x01\x90V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90Ra\x01\x80\x91a\x05/V[` `@Q\x80\x83\x03\x81\x85Z\xFA\x15\x80\x15a\x01\x9BW=_\x80>=_\xFD[PPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x01\xBE\x91\x90a\x05EV[`\x02a\x01\xC9\x87a\0\x94V[`@\x80Q` \x81\x01\x92\x90\x92R\x81\x01\x87\x90R``\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90Ra\x01\xF7\x91a\x05/V[` `@Q\x80\x83\x03\x81\x85Z\xFA\x15\x80\x15a\x02\x12W=_\x80>=_\xFD[PPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x025\x91\x90a\x05EV[`@\x80Q` \x81\x01\x93\x90\x93R\x82\x01R``\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90Ra\x02a\x91a\x05/V[` `@Q\x80\x83\x03\x81\x85Z\xFA\x15\x80\x15a\x02|W=_\x80>=_\xFD[PPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x02\x9F\x91\x90a\x05EV[\x90P_`\x02\x82\x88`@Q` \x01a\x02\xC0\x92\x91\x90\x91\x82R` \x82\x01R`@\x01\x90V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90Ra\x02\xDA\x91a\x05/V[` `@Q\x80\x83\x03\x81\x85Z\xFA\x15\x80\x15a\x02\xF5W=_\x80>=_\xFD[PPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x019\x91\x90a\x05EV[_`@Q\x82Q`@\x81\x14a\x034W`A\x81\x14a\x03UWPa\x03\x90V[`@\x84\x01Q`\xFF\x81\x90\x1C`\x1B\x01` R`\x01`\x01`\xFF\x1B\x03\x16``Ra\x03hV[``\x84\x01Q_\x1A` R`@\x84\x01Q``R[P\x83_R` \x83\x01Q`@R` `\x01`\x80_`\x01Z\xFAQ\x91P_``R\x80`@R=a\x03\x9DW[c\x8B\xAAW\x9F_R`\x04`\x1C\xFD[P\x92\x91PPV[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x14a\x03\xBBW_\x80\xFD[\x91\x90PV[_` \x82\x84\x03\x12\x15a\x03\xD0W_\x80\xFD[a\x01\x17\x82a\x03\xA4V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[_\x80_\x80_\x80`\xC0\x87\x89\x03\x12\x15a\x04\x02W_\x80\xFD[\x865\x95P` \x87\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15a\x04 W_\x80\xFD[\x81\x89\x01\x91P\x89`\x1F\x83\x01\x12a\x043W_\x80\xFD[\x815\x81\x81\x11\x15a\x04EWa\x04Ea\x03\xD9V[`@Q`\x1F\x82\x01`\x1F\x19\x90\x81\x16`?\x01\x16\x81\x01\x90\x83\x82\x11\x81\x83\x10\x17\x15a\x04mWa\x04ma\x03\xD9V[\x81`@R\x82\x81R\x8C` \x84\x87\x01\x01\x11\x15a\x04\x85W_\x80\xFD[\x82` \x86\x01` \x83\x017_` \x84\x83\x01\x01R\x80\x99PPPPPP`@\x87\x015\x93P``\x87\x015\x92Pa\x04\xB9`\x80\x88\x01a\x03\xA4V[\x91P`\xA0\x87\x015\x90P\x92\x95P\x92\x95P\x92\x95V[\x80\x82\x02\x81\x15\x82\x82\x04\x84\x14\x17a\x04\xEFWcNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[\x92\x91PPV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[\x80Q` \x80\x83\x01Q\x91\x90\x81\x10\x15a\x05)W_\x19\x81` \x03`\x03\x1B\x1B\x82\x16\x91P[P\x91\x90PV[_\x82Q\x80` \x85\x01\x84^_\x92\x01\x91\x82RP\x91\x90PV[_` \x82\x84\x03\x12\x15a\x05UW_\x80\xFD[PQ\x91\x90PV\xFE\xA2dipfsX\"\x12 \xC4\xAFD\xFE\x18\x1E\xB3*4\xFB\x04\xB0W\xE2R\xD8\x90\x1C\x15:\xF5\x03\xCC\xA2\x9Bt\xF5Xw\xF4D\x1EdsolcC\0\x08\x19\x003",
    );
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	/**Function with signature `_toLittleEndian(uint64)` and selector `0x5eea787d`.
	```solidity
	function _toLittleEndian(uint64 x) external pure returns (bytes32);
	```*/
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct _toLittleEndianCall {
		#[allow(missing_docs)]
		pub x: u64,
	}
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	///Container type for the return parameters of the [`_toLittleEndian(uint64)`](_toLittleEndianCall) function.
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct _toLittleEndianReturn {
		#[allow(missing_docs)]
		pub _0: alloy::sol_types::private::FixedBytes<32>,
	}
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
	const _: () = {
		use alloy::sol_types as alloy_sol_types;
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = (u64,);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<_toLittleEndianCall> for UnderlyingRustTuple<'_> {
				fn from(value: _toLittleEndianCall) -> Self {
					(value.x,)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for _toLittleEndianCall {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self { x: tuple.0 }
				}
			}
		}
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<_toLittleEndianReturn> for UnderlyingRustTuple<'_> {
				fn from(value: _toLittleEndianReturn) -> Self {
					(value._0,)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for _toLittleEndianReturn {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self { _0: tuple.0 }
				}
			}
		}
		#[automatically_derived]
		impl alloy_sol_types::SolCall for _toLittleEndianCall {
			type Parameters<'a> = (alloy::sol_types::sol_data::Uint<64>,);
			type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
			type Return = alloy::sol_types::private::FixedBytes<32>;
			type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
			type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
			const SIGNATURE: &'static str = "_toLittleEndian(uint64)";
			const SELECTOR: [u8; 4] = [94u8, 234u8, 120u8, 125u8];
			#[inline]
			fn new<'a>(tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType) -> Self {
				tuple.into()
			}
			#[inline]
			fn tokenize(&self) -> Self::Token<'_> {
				(<alloy::sol_types::sol_data::Uint<64> as alloy_sol_types::SolType>::tokenize(&self.x),)
			}
			#[inline]
			fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
				(<alloy::sol_types::sol_data::FixedBytes<32> as alloy_sol_types::SolType>::tokenize(ret),)
			}
			#[inline]
			fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(data).map(|r| {
					let r: _toLittleEndianReturn = r.into();
					r._0
				})
			}
			#[inline]
			fn abi_decode_returns_validate(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence_validate(data).map(|r| {
					let r: _toLittleEndianReturn = r.into();
					r._0
				})
			}
		}
	};
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	/**Function with signature `recover(bytes32,bytes,bytes32,bytes32,uint64,bytes32)` and selector `0xc859272c`.
	```solidity
	function recover(bytes32 messageHash, bytes memory signature, bytes32 signingDomain, bytes32 signingId, uint64 nonce, bytes32 chainId) external view returns (address);
	```*/
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct recoverCall {
		#[allow(missing_docs)]
		pub messageHash: alloy::sol_types::private::FixedBytes<32>,
		#[allow(missing_docs)]
		pub signature: alloy::sol_types::private::Bytes,
		#[allow(missing_docs)]
		pub signingDomain: alloy::sol_types::private::FixedBytes<32>,
		#[allow(missing_docs)]
		pub signingId: alloy::sol_types::private::FixedBytes<32>,
		#[allow(missing_docs)]
		pub nonce: u64,
		#[allow(missing_docs)]
		pub chainId: alloy::sol_types::private::FixedBytes<32>,
	}
	#[derive(serde::Serialize, serde::Deserialize, Default, Debug, PartialEq, Eq, Hash)]
	///Container type for the return parameters of the [`recover(bytes32,bytes,bytes32,bytes32,uint64,bytes32)`](recoverCall) function.
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
	#[derive(Clone)]
	pub struct recoverReturn {
		#[allow(missing_docs)]
		pub _0: alloy::sol_types::private::Address,
	}
	#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
	const _: () = {
		use alloy::sol_types as alloy_sol_types;
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (
				alloy::sol_types::sol_data::FixedBytes<32>,
				alloy::sol_types::sol_data::Bytes,
				alloy::sol_types::sol_data::FixedBytes<32>,
				alloy::sol_types::sol_data::FixedBytes<32>,
				alloy::sol_types::sol_data::Uint<64>,
				alloy::sol_types::sol_data::FixedBytes<32>,
			);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = (
				alloy::sol_types::private::FixedBytes<32>,
				alloy::sol_types::private::Bytes,
				alloy::sol_types::private::FixedBytes<32>,
				alloy::sol_types::private::FixedBytes<32>,
				u64,
				alloy::sol_types::private::FixedBytes<32>,
			);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<recoverCall> for UnderlyingRustTuple<'_> {
				fn from(value: recoverCall) -> Self {
					(
						value.messageHash,
						value.signature,
						value.signingDomain,
						value.signingId,
						value.nonce,
						value.chainId,
					)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for recoverCall {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self {
						messageHash: tuple.0,
						signature: tuple.1,
						signingDomain: tuple.2,
						signingId: tuple.3,
						nonce: tuple.4,
						chainId: tuple.5,
					}
				}
			}
		}
		{
			#[doc(hidden)]
			#[allow(dead_code)]
			type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
			#[doc(hidden)]
			type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
			#[cfg(test)]
			#[allow(dead_code, unreachable_patterns)]
			fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
				match _t {
					alloy_sol_types::private::AssertTypeEq::<
						<UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
					>(_) => {}
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<recoverReturn> for UnderlyingRustTuple<'_> {
				fn from(value: recoverReturn) -> Self {
					(value._0,)
				}
			}
			#[automatically_derived]
			#[doc(hidden)]
			impl ::core::convert::From<UnderlyingRustTuple<'_>> for recoverReturn {
				fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
					Self { _0: tuple.0 }
				}
			}
		}
		#[automatically_derived]
		impl alloy_sol_types::SolCall for recoverCall {
			type Parameters<'a> = (
				alloy::sol_types::sol_data::FixedBytes<32>,
				alloy::sol_types::sol_data::Bytes,
				alloy::sol_types::sol_data::FixedBytes<32>,
				alloy::sol_types::sol_data::FixedBytes<32>,
				alloy::sol_types::sol_data::Uint<64>,
				alloy::sol_types::sol_data::FixedBytes<32>,
			);
			type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
			type Return = alloy::sol_types::private::Address;
			type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
			type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
			const SIGNATURE: &'static str = "recover(bytes32,bytes,bytes32,bytes32,uint64,bytes32)";
			const SELECTOR: [u8; 4] = [200u8, 89u8, 39u8, 44u8];
			#[inline]
			fn new<'a>(tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType) -> Self {
				tuple.into()
			}
			#[inline]
			fn tokenize(&self) -> Self::Token<'_> {
				(
					<alloy::sol_types::sol_data::FixedBytes<32> as alloy_sol_types::SolType>::tokenize(
						&self.messageHash,
					),
					<alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(&self.signature),
					<alloy::sol_types::sol_data::FixedBytes<32> as alloy_sol_types::SolType>::tokenize(
						&self.signingDomain,
					),
					<alloy::sol_types::sol_data::FixedBytes<32> as alloy_sol_types::SolType>::tokenize(&self.signingId),
					<alloy::sol_types::sol_data::Uint<64> as alloy_sol_types::SolType>::tokenize(&self.nonce),
					<alloy::sol_types::sol_data::FixedBytes<32> as alloy_sol_types::SolType>::tokenize(&self.chainId),
				)
			}
			#[inline]
			fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
				(<alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(ret),)
			}
			#[inline]
			fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(data).map(|r| {
					let r: recoverReturn = r.into();
					r._0
				})
			}
			#[inline]
			fn abi_decode_returns_validate(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
				<Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence_validate(data).map(|r| {
					let r: recoverReturn = r.into();
					r._0
				})
			}
		}
	};
	///Container for all the [`ECDSAUtils`](self) function calls.
	#[derive(Clone, serde::Serialize, serde::Deserialize)]
	pub enum ECDSAUtilsCalls {
		#[allow(missing_docs)]
		_toLittleEndian(_toLittleEndianCall),
		#[allow(missing_docs)]
		recover(recoverCall),
	}
	impl ECDSAUtilsCalls {
		/// All the selectors of this enum.
		///
		/// Note that the selectors might not be in the same order as the variants.
		/// No guarantees are made about the order of the selectors.
		///
		/// Prefer using `SolInterface` methods instead.
		pub const SELECTORS: &'static [[u8; 4usize]] = &[[94u8, 234u8, 120u8, 125u8], [200u8, 89u8, 39u8, 44u8]];
		/// The names of the variants in the same order as `SELECTORS`.
		pub const VARIANT_NAMES: &'static [&'static str] =
			&[::core::stringify!(_toLittleEndian), ::core::stringify!(recover)];
		/// The signatures in the same order as `SELECTORS`.
		pub const SIGNATURES: &'static [&'static str] = &[
			<_toLittleEndianCall as alloy_sol_types::SolCall>::SIGNATURE,
			<recoverCall as alloy_sol_types::SolCall>::SIGNATURE,
		];
		/// Returns the signature for the given selector, if known.
		#[inline]
		pub fn signature_by_selector(selector: [u8; 4usize]) -> ::core::option::Option<&'static str> {
			match Self::SELECTORS.binary_search(&selector) {
				::core::result::Result::Ok(idx) => ::core::option::Option::Some(Self::SIGNATURES[idx]),
				::core::result::Result::Err(_) => ::core::option::Option::None,
			}
		}
		/// Returns the enum variant name for the given selector, if known.
		#[inline]
		pub fn name_by_selector(selector: [u8; 4usize]) -> ::core::option::Option<&'static str> {
			let sig = Self::signature_by_selector(selector)?;
			sig.split_once('(').map(|(name, _)| name)
		}
	}
	#[automatically_derived]
	impl alloy_sol_types::SolInterface for ECDSAUtilsCalls {
		const NAME: &'static str = "ECDSAUtilsCalls";
		const MIN_DATA_LENGTH: usize = 32usize;
		const COUNT: usize = 2usize;
		#[inline]
		fn selector(&self) -> [u8; 4] {
			match self {
				Self::_toLittleEndian(_) => <_toLittleEndianCall as alloy_sol_types::SolCall>::SELECTOR,
				Self::recover(_) => <recoverCall as alloy_sol_types::SolCall>::SELECTOR,
			}
		}
		#[inline]
		fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
			Self::SELECTORS.get(i).copied()
		}
		#[inline]
		fn valid_selector(selector: [u8; 4]) -> bool {
			Self::SELECTORS.binary_search(&selector).is_ok()
		}
		#[inline]
		#[allow(non_snake_case)]
		fn abi_decode_raw(selector: [u8; 4], data: &[u8]) -> alloy_sol_types::Result<Self> {
			static DECODE_SHIMS: &[fn(&[u8]) -> alloy_sol_types::Result<ECDSAUtilsCalls>] = &[
				{
					fn _toLittleEndian(data: &[u8]) -> alloy_sol_types::Result<ECDSAUtilsCalls> {
						<_toLittleEndianCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
							.map(ECDSAUtilsCalls::_toLittleEndian)
					}
					_toLittleEndian
				},
				{
					fn recover(data: &[u8]) -> alloy_sol_types::Result<ECDSAUtilsCalls> {
						<recoverCall as alloy_sol_types::SolCall>::abi_decode_raw(data).map(ECDSAUtilsCalls::recover)
					}
					recover
				},
			];
			let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
				return Err(alloy_sol_types::Error::unknown_selector(
					<Self as alloy_sol_types::SolInterface>::NAME,
					selector,
				));
			};
			DECODE_SHIMS[idx](data)
		}
		#[inline]
		#[allow(non_snake_case)]
		fn abi_decode_raw_validate(selector: [u8; 4], data: &[u8]) -> alloy_sol_types::Result<Self> {
			static DECODE_VALIDATE_SHIMS: &[fn(&[u8]) -> alloy_sol_types::Result<ECDSAUtilsCalls>] = &[
				{
					fn _toLittleEndian(data: &[u8]) -> alloy_sol_types::Result<ECDSAUtilsCalls> {
						<_toLittleEndianCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(data)
							.map(ECDSAUtilsCalls::_toLittleEndian)
					}
					_toLittleEndian
				},
				{
					fn recover(data: &[u8]) -> alloy_sol_types::Result<ECDSAUtilsCalls> {
						<recoverCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(data)
							.map(ECDSAUtilsCalls::recover)
					}
					recover
				},
			];
			let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
				return Err(alloy_sol_types::Error::unknown_selector(
					<Self as alloy_sol_types::SolInterface>::NAME,
					selector,
				));
			};
			DECODE_VALIDATE_SHIMS[idx](data)
		}
		#[inline]
		fn abi_encoded_size(&self) -> usize {
			match self {
				Self::_toLittleEndian(inner) => {
					<_toLittleEndianCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
				}
				Self::recover(inner) => <recoverCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
			}
		}
		#[inline]
		fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
			match self {
				Self::_toLittleEndian(inner) => {
					<_toLittleEndianCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
				}
				Self::recover(inner) => <recoverCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
			}
		}
	}
	use alloy::contract as alloy_contract;
	/**Creates a new wrapper around an on-chain [`ECDSAUtils`](self) contract instance.

	See the [wrapper's documentation](`ECDSAUtilsInstance`) for more details.*/
	#[inline]
	pub const fn new<P: alloy_contract::private::Provider<N>, N: alloy_contract::private::Network>(
		address: alloy_sol_types::private::Address,
		__provider: P,
	) -> ECDSAUtilsInstance<P, N> {
		ECDSAUtilsInstance::<P, N>::new(address, __provider)
	}
	/**Deploys this contract using the given `provider` and constructor arguments, if any.

	Returns a new instance of the contract, if the deployment was successful.

	For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
	#[inline]
	pub fn deploy<P: alloy_contract::private::Provider<N>, N: alloy_contract::private::Network>(
		__provider: P,
	) -> impl ::core::future::Future<Output = alloy_contract::Result<ECDSAUtilsInstance<P, N>>> {
		ECDSAUtilsInstance::<P, N>::deploy(__provider)
	}
	/**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
	and constructor arguments, if any.

	This is a simple wrapper around creating a `RawCallBuilder` with the data set to
	the bytecode concatenated with the constructor's ABI-encoded arguments.*/
	#[inline]
	pub fn deploy_builder<P: alloy_contract::private::Provider<N>, N: alloy_contract::private::Network>(
		__provider: P,
	) -> alloy_contract::RawCallBuilder<P, N> {
		ECDSAUtilsInstance::<P, N>::deploy_builder(__provider)
	}
	/**A [`ECDSAUtils`](self) instance.

	Contains type-safe methods for interacting with an on-chain instance of the
	[`ECDSAUtils`](self) contract located at a given `address`, using a given
	provider `P`.

	If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
	documentation on how to provide it), the `deploy` and `deploy_builder` methods can
	be used to deploy a new instance of the contract.

	See the [module-level documentation](self) for all the available methods.*/
	#[derive(Clone)]
	pub struct ECDSAUtilsInstance<P, N = alloy_contract::private::Ethereum> {
		address: alloy_sol_types::private::Address,
		provider: P,
		_network: ::core::marker::PhantomData<N>,
	}
	#[automatically_derived]
	impl<P, N> ::core::fmt::Debug for ECDSAUtilsInstance<P, N> {
		#[inline]
		fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
			f.debug_tuple("ECDSAUtilsInstance").field(&self.address).finish()
		}
	}
	/// Instantiation and getters/setters.
	impl<P: alloy_contract::private::Provider<N>, N: alloy_contract::private::Network> ECDSAUtilsInstance<P, N> {
		/**Creates a new wrapper around an on-chain [`ECDSAUtils`](self) contract instance.

		See the [wrapper's documentation](`ECDSAUtilsInstance`) for more details.*/
		#[inline]
		pub const fn new(address: alloy_sol_types::private::Address, __provider: P) -> Self {
			Self { address, provider: __provider, _network: ::core::marker::PhantomData }
		}
		/**Deploys this contract using the given `provider` and constructor arguments, if any.

		Returns a new instance of the contract, if the deployment was successful.

		For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
		#[inline]
		pub async fn deploy(__provider: P) -> alloy_contract::Result<ECDSAUtilsInstance<P, N>> {
			let call_builder = Self::deploy_builder(__provider);
			let contract_address = call_builder.deploy().await?;
			Ok(Self::new(contract_address, call_builder.provider))
		}
		/**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
		and constructor arguments, if any.

		This is a simple wrapper around creating a `RawCallBuilder` with the data set to
		the bytecode concatenated with the constructor's ABI-encoded arguments.*/
		#[inline]
		pub fn deploy_builder(__provider: P) -> alloy_contract::RawCallBuilder<P, N> {
			alloy_contract::RawCallBuilder::new_raw_deploy(__provider, ::core::clone::Clone::clone(&BYTECODE))
		}
		/// Returns a reference to the address.
		#[inline]
		pub const fn address(&self) -> &alloy_sol_types::private::Address {
			&self.address
		}
		/// Sets the address.
		#[inline]
		pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
			self.address = address;
		}
		/// Sets the address and returns `self`.
		pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
			self.set_address(address);
			self
		}
		/// Returns a reference to the provider.
		#[inline]
		pub const fn provider(&self) -> &P {
			&self.provider
		}
	}
	impl<P: ::core::clone::Clone, N> ECDSAUtilsInstance<&P, N> {
		/// Clones the provider and returns a new instance with the cloned provider.
		#[inline]
		pub fn with_cloned_provider(self) -> ECDSAUtilsInstance<P, N> {
			ECDSAUtilsInstance {
				address: self.address,
				provider: ::core::clone::Clone::clone(&self.provider),
				_network: ::core::marker::PhantomData,
			}
		}
	}
	/// Function calls.
	impl<P: alloy_contract::private::Provider<N>, N: alloy_contract::private::Network> ECDSAUtilsInstance<P, N> {
		/// Creates a new call builder using this contract instance's provider and address.
		///
		/// Note that the call can be any function call, not just those defined in this
		/// contract. Prefer using the other methods for building type-safe contract calls.
		pub fn call_builder<C: alloy_sol_types::SolCall>(&self, call: &C) -> alloy_contract::SolCallBuilder<&P, C, N> {
			alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
		}
		///Creates a new call builder for the [`_toLittleEndian`] function.
		pub fn _toLittleEndian(&self, x: u64) -> alloy_contract::SolCallBuilder<&P, _toLittleEndianCall, N> {
			self.call_builder(&_toLittleEndianCall { x })
		}
		///Creates a new call builder for the [`recover`] function.
		pub fn recover(
			&self,
			messageHash: alloy::sol_types::private::FixedBytes<32>,
			signature: alloy::sol_types::private::Bytes,
			signingDomain: alloy::sol_types::private::FixedBytes<32>,
			signingId: alloy::sol_types::private::FixedBytes<32>,
			nonce: u64,
			chainId: alloy::sol_types::private::FixedBytes<32>,
		) -> alloy_contract::SolCallBuilder<&P, recoverCall, N> {
			self.call_builder(&recoverCall { messageHash, signature, signingDomain, signingId, nonce, chainId })
		}
	}
	/// Event filters.
	impl<P: alloy_contract::private::Provider<N>, N: alloy_contract::private::Network> ECDSAUtilsInstance<P, N> {
		/// Creates a new event filter using this contract instance's provider and address.
		///
		/// Note that the type can be any event, not just those defined in this contract.
		/// Prefer using the other methods for building type-safe event filters.
		pub fn event_filter<E: alloy_sol_types::SolEvent>(&self) -> alloy_contract::Event<&P, E, N> {
			alloy_contract::Event::new_sol(&self.provider, &self.address)
		}
	}
}
